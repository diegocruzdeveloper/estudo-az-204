<!DOCTYPE html>
<html lang="pt-BR" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guia de Estudos Interativo AZ-204</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F8F7F4;
            color: #3D405B;
        }
       .chart-container {
            position: relative;
            margin: auto;
            height: 30vh;
            width: 100%;
            max-width: 400px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
           .chart-container {
                height: 40vh;
            }
        }
       .nav-button {
            transition: all 0.3s ease;
        }
       .nav-button.active {
            background-color: #81B29A;
            color: white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
       .nav-button:not(.active):hover {
            background-color: #e8e6e1;
        }
       .service-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
       .service-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
       .code-block {
            position: relative;
        }
       .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #F8F7F4;
            color: #3D405B;
            border: 1px solid #c7c6c3;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
       .copy-button:hover {
            background-color: #e8e6e1;
        }
       .hidden-view {
            display: none;
        }
       .modal {
            display: none;
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 40;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
       .modal-content {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            max-width: 48rem;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }
       .modal-header {
            position: sticky;
            top: 0;
            background-color: white;
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 10;
        }
       .modal-body {
            padding: 2rem;
            padding-top: 0;
        }
       .prose ul {
            list-style-type: disc;
            margin-left: 1.25em;
        }
       .prose ul li {
            margin-bottom: 0.5em;
        }
       .question-card {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            margin-bottom: 1.5rem;
        }
       .question-card .question-text {
            font-weight: 600;
            margin-bottom: 1rem;
        }
       .question-card .answer-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
        }
       .question-card .answer-correct {
            color: #10B981; /* Tailwind green-500 */
            font-weight: 600;
        }
       .question-card .answer-explanation {
            font-size: 0.875rem;
            color: #4B5563; /* Tailwind gray-600 */
            margin-top: 0.5rem;
        }
       .question-card .show-answer-button {
            background-color: #E07A5F;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
       .question-card .show-answer-button:hover {
            background-color: #c7644a;
        }
    </style>
</head>
<body>
    <header class="bg-white/80 backdrop-blur-md sticky top-0 z-30 shadow-sm">
        <nav class="container mx-auto px-4 sm:px-6 lg:px-8 py-3">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <div class="w-10 h-10 bg-[#81B29A] rounded-full flex items-center justify-center text-white font-bold text-lg">A</div>
                    <h1 class="text-xl md:text-2xl font-bold text-[#3D405B]">Guia de Estudos AZ-204</h1>
                </div>
                <div class="hidden md:flex items-center space-x-2 bg-gray-200/50 p-1 rounded-full">
                    <button id="dashboard-nav-button" class="nav-button px-4 py-2 rounded-full text-sm font-semibold active">Painel</button>
                    <button id="compare-nav-button" class="nav-button px-4 py-2 rounded-full text-sm font-semibold">Comparar Serviços</button>
                    <button id="cli-nav-button" class="nav-button px-4 py-2 rounded-full text-sm font-semibold">CLI & SDK</button>
                    <button id="quiz-nav-button" class="nav-button px-4 py-2 rounded-full text-sm font-semibold">Simulado</button>
                </div>
                 <div class="md:hidden">
                    <select id="mobile-nav-select" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        <option value="dashboard">Painel</option>
                        <option value="compare">Comparar</option>
                        <option value="cli">CLI & SDK</option>
                        <option value="quiz">Simulado</option>
                    </select>
                </div>
            </div>
        </nav>
    </header>

    <main class="container mx-auto p-4 sm:p-6 lg:p-8">

        <div id="dashboard-view" class="">
            <section id="dashboard" class="text-center mb-12">
                <h2 class="text-3xl font-bold mb-2">Painel de Tópicos do Exame AZ-204</h2>
                <p class="text-lg text-gray-600 max-w-3xl mx-auto">Visualize a distribuição dos tópicos do exame e explore os serviços PaaS do Azure. Clique em uma seção do gráfico ou em um filtro para focar em uma área de conhecimento.</p>
            </section>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-12">
                <div class="lg:col-span-1 bg-white p-6 rounded-2xl shadow-lg">
                    <h3 class="text-xl font-bold text-center mb-4">Peso dos Domínios no Exame</h3>
                    <div class="chart-container">
                        <canvas id="examWeightsChart"></canvas>
                    </div>
                </div>
                <div class="lg:col-span-2 bg-white p-6 rounded-2xl shadow-lg flex flex-col justify-center">
                     <h3 class="text-xl font-bold text-center mb-4">Filtro por Domínio</h3>
                     <p class="text-center text-gray-500 mb-6">Selecione um domínio para ver os serviços relacionados.</p>
                    <div id="domain-filter-buttons" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-5 gap-3">
                        <button data-filter="all" class="filter-button p-3 rounded-lg text-sm font-semibold transition-colors duration-200 bg-[#81B29A] text-white">Todos</button>
                        </div>
                </div>
            </div>

            <section id="services">
                <h2 class="text-2xl font-bold mb-6 text-center">Serviços PaaS do Azure</h2>
                <div id="services-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                    </div>
                 <div id="no-services-message" class="text-center py-16 hidden">
                    <p class="text-gray-500">Nenhum serviço encontrado para este filtro.</p>
                </div>
            </section>
        </div>

        <div id="compare-view" class="hidden-view">
            <section id="comparison" class="text-center mb-12">
                 <h2 class="text-3xl font-bold mb-2">Análise Comparativa de Serviços</h2>
                 <p class="text-lg text-gray-600 max-w-3xl mx-auto">Selecione dois serviços para comparar suas características, casos de uso e limitações lado a lado.</p>
            </section>

            <div class="bg-white p-6 rounded-2xl shadow-lg mb-8">
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-end">
                    <div>
                        <label for="compare1" class="block text-sm font-medium text-gray-700">Serviço 1</label>
                        <select id="compare1" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-[#81B29A] focus:border-[#81B29A] sm:text-sm rounded-md">
                            <option value="">Selecione...</option>
                            </select>
                    </div>
                    <div>
                        <label for="compare2" class="block text-sm font-medium text-gray-700">Serviço 2</label>
                         <select id="compare2" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-[#81B29A] focus:border-[#81B29A] sm:text-sm rounded-md">
                            <option value="">Selecione...</option>
                             </select>
                    </div>
                 </div>
            </div>

            <div id="comparison-results">
                 <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                     <div class="lg:col-span-3">
                         <div id="comparison-columns" class="grid grid-cols-1 md:grid-cols-2 gap-8">
                             </div>
                     </div>
                     <div class="lg:col-span-2 bg-white p-6 rounded-2xl shadow-lg">
                         <h3 class="text-xl font-bold text-center mb-4">Gráfico Comparativo</h3>
                         <div class="chart-container" style="max-width: 500px; height: 45vh;">
                             <canvas id="comparisonChart"></canvas>
                         </div>
                     </div>
                 </div>
            </div>
            <div id="no-comparison-selected" class="text-center py-16 bg-gray-50 rounded-2xl">
                <p class="text-gray-500">Por favor, selecione dois serviços para iniciar a comparação.</p>
            </div>
        </div>
        
        <div id="cli-view" class="hidden-view">
            <section id="cli_sdk" class="text-center mb-12">
                 <h2 class="text-3xl font-bold mb-2">Referência Rápida: CLI & SDK</h2>
                 <p class="text-lg text-gray-600 max-w-3xl mx-auto">Uma coleção consolidada dos comandos e trechos de código mais importantes para cada serviço. <strong class="text-red-600">Importante: Estes comandos devem ser executados no seu Azure Cloud Shell ou ambiente local com a Azure CLI/SDK autenticada. Nunca insira credenciais sensíveis diretamente em uma página web.</strong></p>
            </section>
            
            <div id="cli-sdk-content" class="space-y-8">
                </div>
        </div>

        <!-- Nova seção de Simulado do Exame -->
        <div id="quiz-view" class="hidden-view">
            <section id="quiz" class="text-center mb-12">
                <h2 class="text-3xl font-bold mb-2">Simulado do Exame AZ-204</h2>
                <p class="text-lg text-gray-600 max-w-3xl mx-auto">Teste seus conhecimentos com perguntas reais do exame. Clique em "Mostrar Resposta" para ver a solução e a explicação.</p>
            </section>

            <div id="quiz-questions-container" class="space-y-6">
                <!-- Perguntas serão renderizadas aqui pelo JS -->
            </div>
        </div>

    </main>
    
    <div id="service-modal" class="modal">
        <div class="modal-content">
             <div class="modal-header">
                <div class="flex items-center space-x-4">
                     <div id="modal-icon-container" class="w-12 h-12 rounded-full flex-shrink-0 flex items-center justify-center">
                        <span id="modal-icon" class="text-3xl text-white"></span>
                    </div>
                    <div>
                        <h2 id="modal-name" class="text-2xl font-bold"></h2>
                        <p id="modal-tagline" class="text-gray-500"></p>
                    </div>
                </div>
                <button id="modal-close-button" class="text-gray-400 hover:text-gray-600">
                    <span class="text-2xl">&times;</span>
                </button>
            </div>
            
            <div id="modal-body-content" class="modal-body space-y-8">
                </div>
        </div>
    </div>
    
    <script>
        const app = (() => {
            let activeView = 'dashboard';
            let activeFilter = 'all';
            let isModalOpen = false;
            let selectedService = null;
            let comparison = {
                service1: '',
                service2: '',
                data1: null,
                data2: null,
            };
            let charts = {};
            const domains = {
                compute: { name: 'Computação', weight: 27.5, color: '#81B29A' },
                storage: { name: 'Armazenamento', weight: 17.5, color: '#F2CC8F' },
                security: { name: 'Segurança', weight: 17.5, color: '#E07A5F' },
                monitoring: { name: 'Monitoramento', weight: 7.5, color: '#3D405B' },
                connectivity: { name: 'Conectividade', weight: 22.5, color: '#8E8D8A' },
            };
            let servicesData = [];
            // Variável quizQuestions declarada uma única vez aqui
            let quizQuestions = []; 

            const views = {
                dashboard: document.getElementById('dashboard-view'),
                compare: document.getElementById('compare-view'),
                cli: document.getElementById('cli-view'),
                quiz: document.getElementById('quiz-view'),
            };

            const navButtons = {
                dashboard: document.getElementById('dashboard-nav-button'),
                compare: document.getElementById('compare-nav-button'),
                cli: document.getElementById('cli-nav-button'),
                quiz: document.getElementById('quiz-nav-button'),
            };

            const mobileNavSelect = document.getElementById('mobile-nav-select');
            const domainFilterButtonsContainer = document.getElementById('domain-filter-buttons');
            const servicesGrid = document.getElementById('services-grid');
            const noServicesMessage = document.getElementById('no-services-message');
            const serviceModal = document.getElementById('service-modal');
            const modalCloseButton = document.getElementById('modal-close-button');
            const modalIconContainer = document.getElementById('modal-icon-container');
            const modalIcon = document.getElementById('modal-icon');
            const modalName = document.getElementById('modal-name');
            const modalTagline = document.getElementById('modal-tagline');
            const modalBodyContent = document.getElementById('modal-body-content');

            const compareSelect1 = document.getElementById('compare1');
            const compareSelect2 = document.getElementById('compare2');
            const comparisonResultsDiv = document.getElementById('comparison-results');
            const noComparisonSelectedDiv = document.getElementById('no-comparison-selected');
            const comparisonColumnsDiv = document.getElementById('comparison-columns');
            const cliSdkContentDiv = document.getElementById('cli-sdk-content');
            const quizQuestionsContainer = document.getElementById('quiz-questions-container');


            const loadData = () => {
                servicesData = [
                    {
                        id: 'acr',
                        name: 'Azure Container Registry (ACR)',
                        tagline: 'Registro gerenciado para imagens de contêiner',
                        domain: 'compute',
                        icon: '🚢',
                        comparison_metrics: { 'Custo': 3, 'Escalabilidade': 4, 'Controle': 4, 'Estado': 5, 'Simplicidade': 3 },
                        details: {
                            overview: `<ul><li>Serviço de registro gerenciado para imagens de contêiner Docker e artefatos relacionados (como gráficos Helm).</li><li>Oferece segurança, replicação geográfica e integração com ferramentas de desenvolvimento e orquestração.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Hospedagem de imagens para implantação em serviços como Azure Kubernetes Service (AKS), Azure Container Instances (ACI) e Azure Container Apps.</li><li>Ideal para pipelines de CI/CD.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Custos associados ao armazenamento e transferência de dados.</li><li>A complexidade pode aumentar com a necessidade de replicação geográfica e segurança avançada.</li></ul>`,
                        },
                        cli: [
                            { command: 'az acr create --resource-group <rg_name> --name <acr_name> --sku Basic', description: 'Cria um novo Registro de Contêiner do Azure.' },
                            { command: 'az acr build --registry <acr_name> --image <image_name>:<tag> .', description: 'Cria uma imagem Docker e a envia para o ACR.' },
                            { command: 'az acr repository list --name <acr_name> --output table', description: 'Lista os repositórios em um ACR.' },
                            { command: 'docker push <acr_name>.azurecr.io/<image_name>:<tag>', description: 'Envia uma imagem Docker local para o ACR (após login).' },
                        ]
                    },
                    {
                        id: 'aci',
                        name: 'Azure Container Instances (ACI)',
                        tagline: 'Execute contêineres sem servidor',
                        domain: 'compute',
                        icon: '🚀',
                        comparison_metrics: { 'Custo': 4, 'Escalabilidade': 3, 'Controle': 2, 'Estado': 2, 'Simplicidade': 5 },
                        details: {
                            overview: `<ul><li>Permite executar contêineres Docker diretamente no Azure sem a necessidade de gerenciar máquinas virtuais ou orquestradores.</li><li>Oferece inicialização rápida e modelo de cobrança por segundo.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Cargas de trabalho simples e isoladas.</li><li>Tarefas de automação e processamento de eventos.</li><li>Ambientes de teste/desenvolvimento.</li><li>Cenários de burst para AKS.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Não é um orquestrador completo (não oferece recursos avançados de rede ou balanceamento de carga como Kubernetes).</li><li>Ideal para cargas de trabalho efêmeras e sem estado.</li></ul>`,
                        },
                        cli: [
                            { command: 'az container create --resource-group <rg_name> --name <container_name> --image <image_name> --dns-name-label <dns_label> --ports 80', description: 'Cria uma instância de contêiner.' },
                            { command: 'az container attach --resource-group <rg_name> --name <container_name>', description: 'Anexa a saída de log de um contêiner.' },
                            { command: 'az container delete --resource-group <rg_name> --name <container_name> --yes', description: 'Exclui uma instância de contêiner.' },
                        ]
                    },
                    {
                        id: 'container_apps',
                        name: 'Azure Container Apps',
                        tagline: 'Microsserviços em contêineres serverless',
                        domain: 'compute',
                        icon: '📦',
                        comparison_metrics: { 'Custo': 4, 'Escalabilidade': 5, 'Controle': 3, 'Estado': 4, 'Simplicidade': 3 },
                        details: {
                            overview: `<ul><li>Construído sobre Kubernetes e tecnologias de código aberto como Dapr, KEDA e Envoy.</li><li>Permite executar microsserviços e aplicativos conteinerizados em um ambiente sem servidor.</li><li>Suporta HTTP/S, gRPC, WebSockets e eventos.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Construção de arquiteturas de microsserviços.</li><li>APIs baseadas em eventos.</li><li>Processamento em segundo plano.</li><li>Aplicações web que precisam de dimensionamento dinâmico e integração com Dapr para resiliência e observabilidade.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Mais complexo que ACI para casos de uso simples.</li><li>Embora seja "sem servidor", ainda há conceitos de orquestração subjacentes que precisam ser compreendidos.</li></ul>`,
                        },
                        cli: [
                            { command: 'az containerapp env create --name <env_name> --resource-group <rg_name> --location <region>', description: 'Cria um ambiente de Container Apps.' },
                            { command: 'az containerapp create --name <app_name> --resource-group <rg_name> --environment <env_name> --image <image_name> --target-port 80 --ingress external', description: 'Cria um Container App a partir de uma imagem.' },
                        ]
                    },
                    {
                        id: 'app_service',
                        name: 'App Service',
                        tagline: 'Hospedagem de apps web e APIs',
                        domain: 'compute',
                        icon: '☁️',
                        comparison_metrics: { 'Custo': 3, 'Escalabilidade': 4, 'Controle': 3, 'Estado': 4, 'Simplicidade': 5 },
                        details: {
                            overview: `<ul><li>Plataforma PaaS totalmente gerenciada para hospedar aplicações web, APIs REST e backends móveis.</li><li>Suporte a múltiplas linguagens (.NET, Java, Node.js, Python, etc.) e contêineres.</li><li>Oferece escalabilidade, alta disponibilidade e integração com outros serviços Azure.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Aplicações web corporativas.</li><li>Sites de e-commerce.</li><li>APIs RESTful para clientes web e móveis.</li><li>Ambientes de desenvolvimento e teste.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Menos controle sobre o sistema operacional subjacente.</li><li>Dependência da plataforma Azure para gerenciamento de infraestrutura.</li><li>Planos de preços podem ser complexos.</li></ul>`,
                        },
                        cli: [
                            { command: 'az webapp up --name <app_name> --resource-group <rg_name> --location <region>', description: 'Cria e implanta uma app web (simplificado).' },
                            { command: 'az webapp create --name <app_name> --resource-group <rg_name> --plan <plan_name>', description: 'Cria uma app web em um plano existente.' },
                            { command: 'az webapp deployment slot create --name <app_name> --resource-group <rg_name> --slot staging', description: 'Cria um slot de implantação.' },
                            { command: 'az webapp deploy --resource-group <rg_name> --name <app_name> --src-path "path/to/your/code.zip"', description: 'Implanta código para uma app web existente a partir de um ZIP.' },
                            { command: 'az webapp config appsettings set --name <app_name> --resource-group <rg_name> --settings "CONNECTION_STRING=YourValue"', description: 'Define uma configuração de aplicativo.' },
                            { command: 'az webapp log config --name <app_name> --resource-group <rg_name> --web-server-logging filesystem --level verbose', description: 'Configura o log do servidor web.' },
                            { command: 'az webapp config set --name <app_name> --resource-group <rg_name> --https-only true', description: 'Força HTTPS para o aplicativo.' },
                            { command: 'az webapp config hostname add --webapp-name <app_name> --resource-group <rg_name> --hostname <custom_domain>', description: 'Adiciona um nome de host personalizado.' },
                            { command: 'az webapp config set --name <app_name> --resource-group <rg_name> --min-replicas 2 --max-replicas 10 --autoscale-rule-type CPU --autoscale-rule-value 70', description: 'Configura o dimensionamento automático (exemplo).' },
                            { command: 'az webapp deployment slot swap --resource-group <rg_name> --name <app_name> --slot staging --target-slot production', description: 'Troca um slot de implantação para produção.' },
                        ]
                    },
                    {
                        id: 'functions',
                        name: 'Azure Functions',
                        tagline: 'Computação serverless orientada a eventos',
                        domain: 'compute',
                        icon: '⚡️',
                        comparison_metrics: { 'Custo': 5, 'Escalabilidade': 5, 'Controle': 2, 'Estado': 2, 'Simplicidade': 4 },
                        details: {
                            overview: `<ul><li>Serviço de computação sem servidor baseado em eventos que permite executar pequenos trechos de código ("funções") sem se preocupar com a infraestrutura.</li><li>Pague apenas pelo tempo de execução do código.</li><li>Implementa associações (bindings) de entrada e saída e gatilhos (HTTP, temporizador, dados, webhooks).</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Processamento de eventos em tempo real.</li><li>Tarefas agendadas.</li><li>APIs leves.</li><li>Processamento de dados e integração de sistemas.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Tempo de execução limitado em planos de consumo.</li><li>Não é ideal para cargas de trabalho de longa duração ou que exigem controle total sobre o ambiente de execução.</li></ul>`,
                        },
                        cli: [
                            { command: 'az functionapp create --name <app_name> --resource-group <rg_name> --consumption-plan-location <region> --runtime node --storage-account <storage>', description: 'Cria um Function App.' },
                            { command: 'func new --name MyHttpTrigger --template "HTTP trigger"', description: 'Cria uma nova função localmente (usando Core Tools).' },
                            { command: 'func host start', description: 'Executa a função localmente para teste (usando Core Tools).' },
                            { command: 'az functionapp deployment source config --name <app_name> --resource-group <rg_name> --branch master --repo-url <repo_url> --git-token <token>', description: 'Configura a implantação contínua de um repositório Git.' },
                            { command: 'az functionapp config appsettings set --name <app_name> --resource-group <rg_name> --settings "AzureWebJobsStorage=<storage_connection_string>"', description: 'Define a string de conexão de armazenamento para o Function App.' },
                            { command: 'func azure functionapp publish <app_name>', description: 'Publica um projeto de funções local para o Azure.' },
                        ]
                    },
                    {
                        id: 'cosmos_db',
                        name: 'Azure Cosmos DB',
                        tagline: 'BD NoSQL globalmente distribuído',
                        domain: 'storage',
                        icon: '�',
                        comparison_metrics: { 'Custo': 2, 'Escalabilidade': 5, 'Controle': 4, 'Estado': 5, 'Simplicidade': 3 },
                        details: {
                            overview: `<ul><li>Banco de dados NoSQL multi-modelo e distribuído globalmente.</li><li>Oferece latência de milissegundos de dígito único em qualquer escala, garantia de alta disponibilidade e consistência.</li><li>APIs para SQL, MongoDB, Cassandra, Gremlin e Table.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Aplicações de IoT e telemetria.</li><li>Jogos (perfis de usuário, placares).</li><li>E-commerce (catálogos de produtos, carrinhos de compra).</li><li>Aplicações web e móveis com requisitos de escala global.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Custo pode ser elevado; requer provisionamento cuidadoso de RUs (Request Units).</li><li>A escolha da chave de partição é CRÍTICA para o desempenho.</li><li>Consultas complexas entre contêineres podem ser ineficientes.</li></ul>`,
                        },
                        cli: [
                            { command: 'az cosmosdb create --name <account_name> --resource-group <rg_name> --locations regionName=<region> failoverPriority=0 --default-consistency-level Session', description: 'Cria uma conta Cosmos DB.' },
                            { command: 'az cosmosdb sql database create --account-name <account_name> --name <db_name> --resource-group <rg_name>', description: 'Cria um banco de dados SQL API.' },
                            { command: 'az cosmosdb sql container create --account-name <account_name> --database-name <db_name> --name <container_name> --partition-key-path /id --throughput 400', description: 'Cria um contêiner SQL API.' },
                        ],
                        sdk: [
                            { description: 'Criar um item (C#)', snippet: `ItemResponse<MyItem> response = await container.CreateItemAsync(item, new PartitionKey(item.partitionKey));` },
                            { description: 'Ler um item (C#)', snippet: `ItemResponse<MyItem> response = await container.ReadItemAsync<MyItem>(itemId, new PartitionKey(partitionKey));` },
                            { description: 'Consultar itens (C#)', snippet: `var query = new QueryDefinition("SELECT * FROM c WHERE c.partitionKey = @key").WithParameter("@key", partitionKey);\nvar iterator = container.GetItemQueryIterator<MyItem>(query);` },
                            { description: 'Atualizar um item (C#)', snippet: `ItemResponse<MyItem> response = await container.UpsertItemAsync(updatedItem, new PartitionKey(updatedItem.partitionKey));` },
                            { description: 'Implementar Feed de Alterações (C# - Exemplo básico com Function)', snippet: `// Exemplo de trigger de Azure Function para Change Feed\n[FunctionName("CosmosDbChangeFeedProcessor")]\npublic static async Task Run([CosmosDBTrigger(\n    databaseName: "myDatabase",\n    containerName: "myContainer",\n    Connection = "CosmosDBConnection",\n    LeaseContainerName = "leases")]IReadOnlyList<Document> input,\n    ILogger log)\n{\n    if (input != null && input.Count > 0)\n    {\n        log.LogInformation("Documents modified: " + input.Count);\n        foreach (var doc in input)\n        {\n            log.LogInformation($"Modified document ID: {doc.Id}");\n        }\n    }\n}` },
                        ]
                    },
                    {
                        id: 'blob_storage',
                        name: 'Azure Blob Storage',
                        tagline: 'Armazenamento de objetos em massa',
                        domain: 'storage',
                        icon: '💾',
                        comparison_metrics: { 'Custo': 5, 'Escalabilidade': 5, 'Controle': 3, 'Estado': 5, 'Simplicidade': 5 },
                        details: {
                            overview: `<ul><li>Solução de armazenamento de objetos altamente escalável e durável para dados não estruturados.</li><li>Permite definir e recuperar propriedades e metadados.</li><li>Implementa políticas de armazenamento e gerenciamento do ciclo de vida de dados.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Armazenamento de arquivos de mídia (imagens, vídeos), documentos, logs, backups.</li><li>Dados para análise de Big Data.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Não é um sistema de arquivos tradicional; não suporta operações de arquivo em nível de byte (apenas objetos completos).</li></ul>`,
                        },
                        cli: [
                            { command: 'az storage account create --name <account_name> --resource-group <rg_name> --location <region> --sku Standard_LRS', description: 'Cria uma conta de armazenamento.' },
                            { command: 'az storage container create --name <container_name> --account-name <account_name> --public-access blob', description: 'Cria um contêiner de blobs.' },
                            { command: 'az storage blob upload --container-name <container_name> --file "local_file.txt" --name "remote_blob.txt" --account-name <account_name>', description: 'Carrega um arquivo para o Blob Storage.' },
                            { command: 'az storage blob download --container-name <container_name> --file "downloaded_file.txt" --name "remote_blob.txt" --account-name <account_name>', description: 'Baixa um blob.' },
                            { command: 'az storage container generate-sas --name <container_name> --account-name <account_name> --permissions rwl --expiry 2025-12-31T00:00Z --output tsv', description: 'Gera uma SAS para um contêiner.' },
                            { command: 'az storage blob show --container-name <container_name> --name <blob_name> --account-name <account_name> --query "properties.contentSettings.contentType"', description: 'Define e recupera propriedades de blob (ex: Content-Type).' },
                            { command: 'az storage blob metadata show --container-name <container_name> --name <blob_name> --account-name <account_name>', description: 'Define e recupera metadados de blob.' },
                            { command: 'az storage blob set-tier --container-name <container_name> --name <blob_name> --account-name <account_name> --tier Cool', description: 'Define a camada de acesso de um blob.' },
                        ],
                        sdk: [
                            { description: 'Upload de Blob (C#)', snippet: `using Azure.Storage.Blobs;\nusing System.IO;\n//...\nBlobServiceClient blobServiceClient = new BlobServiceClient("YourConnectionString");\nBlobContainerClient containerClient = blobServiceClient.GetBlobContainerClient("mycontainer");\nawait containerClient.CreateIfNotExistsAsync();\nBlobClient blobClient = containerClient.GetBlobClient("myblob.txt");\nusing (FileStream uploadFileStream = File.OpenRead("path/to/local/file.txt"))\n{\n    await blobClient.UploadAsync(uploadFileStream, true);\n    Console.WriteLine("Blob uploaded.");\n}` },
                            { description: 'Download de Blob (C#)', snippet: `using Azure.Storage.Blobs;\nusing System.IO;\n//...\nBlobClient blobClient = containerClient.GetBlobClient("myblob.txt");\nusing (MemoryStream downloadStream = new MemoryStream())\n{\n    await blobClient.DownloadToAsync(downloadStream);\n    downloadStream.Position = 0;\n    using (StreamReader reader = new StreamReader(downloadStream))\n    {\n        string content = await reader.ReadToEndAsync();\n        Console.WriteLine($"Blob content: {content}");\n    }\n}` },
                            { description: 'Definir Propriedades/Metadados (C#)', snippet: `using Azure.Storage.Blobs.Models;\n//...\nBlobClient blobClient = containerClient.GetBlobClient("myblob.txt");\nBlobHttpHeaders headers = new BlobHttpHeaders { ContentType = "text/plain" };\nawait blobClient.SetHttpHeadersAsync(headers);\n\nIDictionary<string, string> metadata = new Dictionary<string, string>\n{\n    { "Author", "Me" },\n    { "Version", "1.0" }\n};\nawait blobClient.SetMetadataAsync(metadata);\nConsole.WriteLine("Properties and metadata set.");` },
                        ]
                    },
                    {
                        id: 'identity_platform',
                        name: 'Microsoft Identity Platform & Entra ID',
                        tagline: 'Autenticação e Autorização de Usuários e Apps',
                        domain: 'security',
                        icon: '👤',
                        comparison_metrics: { 'Custo': 4, 'Escalabilidade': 5, 'Controle': 5, 'Estado': 5, 'Simplicidade': 2 },
                        details: {
                            overview: `<ul><li>Conjunto de serviços de identidade baseados em nuvem para autenticação e autorização de usuários e aplicativos.</li><li>Microsoft Entra ID (antigo Azure AD) é o serviço de diretório principal.</li><li>Permite autenticar e autorizar usuários e aplicativos usando a plataforma Microsoft Identity.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Autenticação de usuários em aplicativos web e móveis.</li><li>Proteção de APIs.</li><li>Gerenciamento de acesso a recursos do Azure.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Requer compreensão dos fluxos de autenticação (OAuth 2.0, OpenID Connect).</li><li>Complexidade na configuração de permissões granulares.</li></ul>`,
                        },
                        cli: [
                            { command: 'az ad app create --display-name <app_name> --homepage "https://<app_url>" --identifier-uris "api://<app_id>"', description: 'Cria um registro de aplicativo no Microsoft Entra ID.' },
                            { command: 'az ad sp create --id <app_id>', description: 'Cria um Service Principal para o aplicativo.' },
                            { command: 'az role assignment create --assignee <app_id> --role "Contributor" --scope /subscriptions/<sub_id>/resourceGroups/<rg_name>', description: 'Concede permissões a um Service Principal.' },
                        ],
                        sdk: [
                            { description: 'Autenticar usuário com MSAL.NET (Exemplo Básico)', snippet: `using Microsoft.Identity.Client;\n//...\nvar app = PublicClientApplicationBuilder.Create("<YourClientID>")\n    .WithRedirectUri("http://localhost")\n    .Build();\n\nvar result = await app.AcquireTokenInteractive(new[] { "user.read" }).ExecuteAsync();\nConsole.WriteLine($"Token: {result.AccessToken}");` },
                            { description: 'Obter token para acessar o Microsoft Graph (Exemplo Básico)', snippet: `using Microsoft.Identity.Client;\n//...\nvar app = ConfidentialClientApplicationBuilder.Create("<YourClientID>")\n    .WithClientSecret("<YourClientSecret>")\n    .WithAuthority(new Uri("https://login.microsoftonline.com/<YourTenantID>"))\n    .Build();\n\nvar result = await app.AcquireTokenForClient(new[] { "https://graph.microsoft.com/.default" }).ExecuteAsync();\nConsole.WriteLine($"Graph Token: {result.AccessToken}");` },
                        ]
                    },
                    {
                        id: 'sas',
                        name: 'Shared Access Signatures (SAS)',
                        tagline: 'Acesso delegado seguro ao Armazenamento',
                        domain: 'security',
                        icon: '🔒',
                        comparison_metrics: { 'Custo': 5, 'Escalabilidade': 4, 'Controle': 3, 'Estado': 4, 'Simplicidade': 4 },
                        details: {
                            overview: `<ul><li>Uma cadeia de caracteres com um URI que concede acesso delegado a recursos do Armazenamento do Azure (Blobs, Filas, Tabelas, Arquivos) com permissões e tempo limitados.</li><li>Permite conceder acesso temporário e seguro a clientes sem compartilhar chaves de conta de armazenamento.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Permitir que aplicativos móveis ou web façam upload/download diretamente para o armazenamento, sem passar por um back-end.</li><li>Conceder acesso limitado a terceiros a recursos específicos.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Gerenciamento de expiração e revogação pode ser complexo.</li><li>Risco de uso indevido se as permissões forem muito amplas ou o tempo de expiração muito longo.</li></ul>`,
                        },
                        cli: [
                            { command: 'az storage container generate-sas --name <container_name> --account-name <account_name> --permissions rwl --expiry 2025-12-31T00:00Z --output tsv', description: 'Gera uma SAS para um contêiner.' },
                            { command: 'az storage blob generate-sas --name <blob_name> --container-name <container_name> --account-name <account_name> --permissions r --expiry 2025-12-31T00:00Z --output tsv', description: 'Gera uma SAS para um blob específico.' },
                        ],
                        sdk: [
                            { description: 'Gerar SAS de Blob (C#)', snippet: `using Azure.Storage.Blobs;\nusing Azure.Storage.Sas;\n//...\nBlobClient blobClient = containerClient.GetBlobClient("myblob.txt");\nBlobSasBuilder sasBuilder = new BlobSasBuilder()\n{\n    BlobContainerName = blobClient.BlobContainerName,\n    BlobName = blobClient.Name,\n    ExpiresOn = DateTimeOffset.UtcNow.AddHours(1),\n    Resource = "b", // 'b' for blob, 'c' for container\n};\nsasBuilder.SetPermissions(BlobSasPermissions.Read | BlobSasPermissions.Write);\nUri sasUri = blobClient.GenerateSasUri(sasBuilder);\nConsole.WriteLine($"SAS URI: {sasUri}");` },
                        ]
                    },
                    {
                        id: 'microsoft_graph',
                        name: 'Microsoft Graph',
                        tagline: 'API unificada para dados da Microsoft 365',
                        domain: 'security',
                        icon: '📈',
                        comparison_metrics: { 'Custo': 4, 'Escalabilidade': 5, 'Controle': 3, 'Estado': 5, 'Simplicidade': 3 },
                        details: {
                            overview: `<ul><li>Uma API unificada que permite acessar dados e inteligência de serviços da Microsoft 365, Windows 10 e Enterprise Mobility + Security.</li><li>Permite interagir com dados de usuários, grupos, arquivos, emails, calendários, etc.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Construir aplicativos que se integram com o ecossistema Microsoft (produtividade, colaboração, gerenciamento de identidade).</li><li>Obter perfil de usuário, gerenciar arquivos no OneDrive, acessar calendários.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Requer permissões adequadas no Microsoft Entra ID.</li><li>Complexidade na navegação da API para dados específicos.</li></ul>`,
                        },
                        sdk: [
                            { description: 'Obter perfil de usuário com Microsoft Graph SDK (C#)', snippet: `using Microsoft.Graph;\nusing Azure.Identity;\n//...\nvar scopes = new[] { "User.Read" };\nvar tenantId = "<YourTenantID>";\nvar clientId = "<YourClientID>";\nvar clientSecret = "<YourClientSecret>";\n\nvar options = new TokenCredentialOptions { AuthorityHost = AzureAuthorityHosts.AzurePublicCloud };\nvar clientSecretCredential = new ClientSecretCredential(tenantId, clientId, clientSecret, options);\nvar graphClient = new GraphServiceClient(clientSecretCredential, scopes);\n\nvar user = await graphClient.Me.GetAsync();\nConsole.WriteLine($"User Display Name: {user.DisplayName}");` },
                        ]
                    },
                    {
                        id: 'app_configuration',
                        name: 'Azure App Configuration',
                        tagline: 'Gerenciamento centralizado de configurações',
                        domain: 'security',
                        icon: '⚙️',
                        comparison_metrics: { 'Custo': 4, 'Escalabilidade': 4, 'Controle': 4, 'Estado': 5, 'Simplicidade': 5 },
                        details: {
                            overview: `<ul><li>Serviço gerenciado para armazenar configurações de aplicativos de forma centralizada e segura.</li><li>Permite gerenciar configurações de forma dinâmica, incluindo sinalizadores de recursos (feature flags).</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Centralizar configurações para microsserviços.</li><li>Gerenciar configurações de ambiente (desenvolvimento, teste, produção).</li><li>Habilitar/desabilitar recursos sem reimplantar o código.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Não é um substituto para o Key Vault para segredos de alta sensibilidade.</li></ul>`,
                        },
                        cli: [
                            { command: 'az appconfig create --name <appconfig_name> --resource-group <rg_name> --location <region> --sku Standard', description: 'Cria um novo recurso do App Configuration.' },
                            { command: 'az appconfig kv set --name <appconfig_name> --key "MySetting" --value "HelloFromAppConfig"', description: 'Define uma chave-valor no App Configuration.' },
                            { command: 'az appconfig kv show --name <appconfig_name> --key "MySetting" --query value --output tsv', description: 'Obtém o valor de uma chave.' },
                        ],
                        sdk: [
                            { description: 'Ler configuração (C#)', snippet: `using Microsoft.Extensions.Configuration;\nusing Azure.Data.AppConfiguration;\n//...\nvar builder = new ConfigurationBuilder();\nbuilder.AddAzureAppConfiguration(options =>\n{\n    options.Connect(Environment.GetEnvironmentVariable("AppConfigConnectionString"))\n           .UseFeatureFlags();\n});\nvar config = builder.Build();\nConsole.WriteLine($"MySetting: {config["MySetting"]}");` },
                        ]
                    },
                    {
                        id: 'key_vault',
                        name: 'Azure Key Vault',
                        tagline: 'Gerenciamento seguro de segredos',
                        domain: 'security',
                        icon: '🔑',
                        comparison_metrics: { 'Custo': 3, 'Escalabilidade': 4, 'Controle': 5, 'Estado': 5, 'Simplicidade': 3 },
                        details: {
                            overview: `<ul><li>Serviço baseado em nuvem para armazenar e gerenciar com segurança chaves criptográficas, segredos (senhas, cadeias de conexão) e certificados.</li><li>Protege chaves e segredos usados por aplicativos e serviços em nuvem.</li><li>Integra com aplicativos para recuperar segredos em tempo de execução.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Armazenar cadeias de conexão de banco de dados, chaves de API, segredos de aplicativos.</li><li>Gerenciar certificados TLS/SSL.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Custos associados ao uso; requer configuração cuidadosa de políticas de acesso.</li><li>Possui limites de throughput; não é para acesso contínuo de alto volume.</li><li>Não é um banco de dados de propósito geral.</li></ul>`,
                        },
                        cli: [
                            { command: 'az keyvault create --resource-group <rg_name> --name <vault_name> --location <region> --sku standard', description: 'Cria um novo Key Vault.' },
                            { command: 'az keyvault secret set --vault-name <vault_name> --name <secret_name> --value "mySuperSecretValue"', description: 'Define um segredo no Key Vault.' },
                            { command: 'az keyvault secret show --vault-name <vault_name> --name <secret_name> --query value --output tsv', description: 'Obtém o valor de um segredo.' },
                            { command: 'az keyvault set-policy --name <vault_name> --resource-group <rg_name> --object-id <object_id> --secret-permissions get list', description: 'Define uma política de acesso para um objeto (ex: Managed Identity).' },
                        ],
                        sdk: [
                            { description: 'Obter Segredo (C#)', snippet: `using Azure.Security.KeyVault.Secrets;\nusing Azure.Identity;\n//...\nSecretClient client = new SecretClient(new Uri("https://<your_vault_name>.vault.azure.net/"), new DefaultAzureCredential());\nKeyVaultSecret secret = await client.GetSecretAsync("mySecretName");\nConsole.WriteLine($"Secret value: {secret.Value}");` },
                        ]
                    },
                    {
                        id: 'managed_identities',
                        name: 'Managed Identities',
                        tagline: 'Identidades para recursos Azure',
                        domain: 'security',
                        icon: '🆔',
                        comparison_metrics: { 'Custo': 5, 'Escalabilidade': 5, 'Controle': 4, 'Estado': 5, 'Simplicidade': 5 },
                        details: {
                            overview: `<ul><li>Recurso do Microsoft Entra ID que fornece uma identidade para serviços do Azure (VMs, App Services, Functions).</li><li>Permite que serviços se autentiquem em outros serviços Azure que suportam autenticação do Microsoft Entra ID, sem a necessidade de gerenciar credenciais.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Simplificar o gerenciamento de credenciais, eliminando a necessidade de armazenar segredos em código ou arquivos de configuração.</li><li>Permitir que um aplicativo web acesse um Key Vault, um Azure SQL Database ou um Armazenamento de Blobs de forma segura.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Só pode ser usada para autenticar em serviços que suportam autenticação do Microsoft Entra ID.</li></ul>`,
                        },
                        cli: [
                            { command: 'az webapp identity assign --resource-group <rg_name> --name <app_name>', description: 'Atribui uma identidade gerenciada atribuída pelo sistema a um App Service.' },
                            { command: 'az keyvault set-policy --name <keyvault_name> --resource-group <rg_name> --object-id <managed_identity_principal_id> --secret-permissions get list', description: 'Concede permissão de Key Vault a uma identidade gerenciada.' },
                        ]
                    },
                    {
                        id: 'app_insights',
                        name: 'Application Insights',
                        tagline: 'Monitoramento de desempenho de apps',
                        domain: 'monitoring',
                        icon: '📊',
                        comparison_metrics: { 'Custo': 3, 'Escalabilidade': 4, 'Controle': 4, 'Estado': 5, 'Simplicidade': 3 },
                        details: {
                            overview: `<ul><li>Serviço de Gerenciamento de Desempenho de Aplicações (APM) para monitorar aplicativos web, APIs e serviços.</li><li>Fornece insights sobre desempenho, disponibilidade e uso.</li><li>Coleta telemetria: solicitações, exceções, dependências, eventos personalizados, logs e rastreamentos.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Monitoramento de desempenho de aplicativos web, APIs, microsserviços, funções sem servidor.</li><li>Identificação de gargalos, erros e problemas de desempenho.</li><li>Configurar alertas e testes web de disponibilidade.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Custos podem aumentar com o volume de telemetria; instrumentação manual pode ser necessária para alguns cenários.</li></ul>`,
                        },
                        cli: [
                            { command: 'az monitor app-insights component create --app <app_insights_name> --location <region> --resource-group <rg_name> --kind web --application-type web', description: 'Cria um novo recurso do Application Insights.' },
                            { command: 'az monitor app-insights metric show --app <app_insights_name> --metric "requests/count" --interval 1h --output table', description: 'Monitora e analisa métricas.' },
                            { command: 'az monitor app-insights query --app <app_insights_name> --analytics-query "traces | limit 10"', description: 'Monitora e analisa logs e rastreamentos (KQL).' },
                            { command: 'az monitor scheduled-query create --resource-group <rg_name> --name <alert_name> --scopes <app_insights_resource_id> --condition "countof(exceptions) > 5" --actions <action_group_id>', description: 'Implementa alertas (exemplo de consulta agendada).' },
                            { command: 'az webapp appinsights set --name <app_name> --resource-group <rg_name> --app-insights <app_insights_name> --enable-instrumentation true', description: 'Instrumenta um aplicativo web para usar o Application Insights.' },
                        ],
                        sdk: [
                            { description: 'Instrumentar uma aplicação ASP.NET Core (C#)', snippet: `// No Startup.cs ou Program.cs\nbuilder.Services.AddApplicationInsightsTelemetry();` },
                            { description: 'Registrar evento personalizado (C#)', snippet: `using Microsoft.ApplicationInsights;\n//...\nTelemetryClient telemetry = new TelemetryClient();\ntelemetry.TrackEvent("MyCustomEvent", new Dictionary<string,string> { {"Property1", "Value1"} });` },
                            { description: 'Registrar exceção (C#)', snippet: `using Microsoft.ApplicationInsights;\n//...\nTelemetryClient telemetry = new TelemetryClient();\ntry { /* Your code */ } catch (Exception ex) { telemetry.TrackException(ex); }` },
                        ]
                    },
                    {
                        id: 'api_management',
                        name: 'Azure API Management (APIM)',
                        tagline: 'Gerenciamento completo de APIs',
                        domain: 'connectivity',
                        icon: '🔗',
                        comparison_metrics: { 'Custo': 2, 'Escalabilidade': 4, 'Controle': 5, 'Estado': 5, 'Simplicidade': 2 },
                        details: {
                            overview: `<ul><li>Serviço PaaS para publicar, gerenciar, proteger e analisar APIs. Atua como um gateway de API.</li><li>Permite criar instâncias, documentar APIs, configurar acesso e implementar políticas.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Expor APIs de forma segura para parceiros e desenvolvedores externos.</li><li>Monetização de APIs.</li><li>Centralização do gerenciamento de APIs.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Custo elevado para instâncias de produção.</li><li>Complexidade na configuração de políticas avançadas.</li></ul>`,
                        },
                        cli: [
                            { command: 'az apim create --name <apim_name> --resource-group <rg_name> --location <region> --publisher-email "admin@example.com" --publisher-name "My Publisher"', description: 'Cria uma instância do Gerenciamento de API do Azure.' },
                            { command: 'az apim api import --path <api_path> --service-url <backend_url> --api-id <api_id> --service-name <apim_name> --resource-group <rg_name> --display-name "My API" --specification-format OpenApiJson --specification-path "path/to/openapi.json"', description: 'Cria e documenta uma API importando uma especificação OpenAPI.' },
                            { command: 'az apim product create --product-id <product_id> --service-name <apim_name> --resource-group <rg_name> --display-name "Starter Product" --subscription-required true --state published', description: 'Cria um produto para agrupar APIs e gerenciar o acesso.' },
                            { command: 'az apim policy create --service-name <apim_name> --resource-group <rg_name> --api-id <api_id> --policy-id "policy" --xml-content "<policies><inbound><rate-limit-by-key calls="10" renewal-period="60" counter-key="@(context.Subscription.Id)"/></inbound></policies>"', description: 'Implementa políticas para APIs (ex: rate limiting).' },
                        ]
                    },
                    {
                        id: 'event_grid',
                        name: 'Azure Event Grid',
                        tagline: 'Roteamento de eventos em tempo real',
                        domain: 'connectivity',
                        icon: '⚡️',
                        comparison_metrics: { 'Custo': 5, 'Escalabilidade': 5, 'Controle': 2, 'Estado': 2, 'Simplicidade': 5 },
                        details: {
                            overview: `<ul><li>Serviço de roteamento de eventos totalmente gerenciado que permite reagir a eventos de serviços Azure e de terceiros em tempo real.</li><li>Permite publicar eventos de fontes (publishers) e inscrever-se em eventos para reagir a eles (subscribers).</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Arquiteturas orientadas a eventos (serverless).</li><li>Automação de processos e integração de sistemas.</li><li>Processamento de dados em tempo real.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Não é uma fila de mensagens; não garante a ordem de entrega para todos os tipos de eventos.</li></ul>`,
                        },
                        cli: [
                            { command: 'az eventgrid topic create --resource-group <rg_name> --name <topic_name> --location <region>', description: 'Cria um tópico personalizado do Event Grid.' },
                            { command: 'az eventgrid event-subscription create --resource-group <rg_name> --name <subscription_name> --source-resource-id "/subscriptions/<sub_id>/resourceGroups/<rg_name>/providers/Microsoft.EventGrid/topics/<topic_name>" --endpoint <webhook_url> --endpoint-type webhook', description: 'Cria uma assinatura de evento para um webhook.' },
                            { command: 'az eventgrid event-subscription create --resource-group <rg_name> --name <subscription_name> --source-resource-id "/subscriptions/<sub_id>/resourceGroups/<rg_name>/providers/Microsoft.Storage/storageAccounts/<storage_account_name>" --endpoint <function_app_endpoint> --endpoint-type azurefunction --included-event-types Microsoft.Storage.BlobCreated', description: 'Cria uma assinatura de evento para uma Azure Function (ex: para Blob Created).' },
                        ]
                    },
                    {
                        id: 'event_hubs',
                        name: 'Azure Event Hubs',
                        tagline: 'Plataforma de streaming de dados em larga escala',
                        domain: 'connectivity',
                        icon: '📡',
                        comparison_metrics: { 'Custo': 3, 'Escalabilidade': 5, 'Controle': 3, 'Estado': 5, 'Simplicidade': 3 },
                        details: {
                            overview: `<ul><li>Plataforma de streaming de dados altamente escalável e de alto throughput.</li><li>Pode ingerir milhões de eventos por segundo.</li><li>Permite ingerir grandes volumes de dados de telemetria e eventos de diversas fontes.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Ingestão de dados de IoT e telemetria de aplicativos.</li><li>Captura de logs distribuídos.</li><li>Processamento de streaming de Big Data.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Não é uma fila de mensagens tradicional para comunicação ponto a ponto.</li><li>Focado em streaming de eventos para múltiplos consumidores.</li></ul>`,
                        },
                        cli: [
                            { command: 'az eventhubs namespace create --resource-group <rg_name> --name <eh_namespace> --location <region> --sku Standard', description: 'Cria um namespace do Event Hubs.' },
                            { command: 'az eventhubs eventhub create --resource-group <rg_name> --namespace-name <eh_namespace> --name <eventhub_name> --partition-count 4', description: 'Cria um Event Hub dentro do namespace.' },
                        ],
                        sdk: [
                            { description: 'Enviar evento (C#)', snippet: `using Azure.Messaging.EventHubs;\nusing Azure.Messaging.EventHubs.Producer;\n//...\nawait using (var producerClient = new EventHubProducerClient("YourConnectionString", "myeventhub"))\n{\n    using EventDataBatch eventBatch = await producerClient.CreateBatchAsync();\n    eventBatch.TryAdd(new EventData("First event"));\n    eventBatch.TryAdd(new EventData("Second event"));\n    await producerClient.SendAsync(eventBatch);\n    Console.WriteLine("Events sent.");\n}` },
                            { description: 'Processar eventos (C#)', snippet: `using Azure.Messaging.EventHubs.Consumer;\nusing Azure.Messaging.EventHubs.Processor;\n//...\nvar consumerGroup = "$Default";\nvar storageConnectionString = "YourStorageConnectionString";\nvar blobContainerName = "eventhub-checkpoint";\n\nEventProcessorClient processor = new EventProcessorClient(\n    new BlobContainerClient(storageConnectionString, blobContainerName),\n    consumerGroup,\n    "YourEventHubConnectionString",\n    "myeventhub");\n\nprocessor.ProcessEventAsync += async (args) =>\n{\n    Console.WriteLine($"Event received from partition {args.Partition.PartitionId}: {args.Data.EventBody.ToString()}");\n    await args.UpdateCheckpointAsync(args.Data);\n};\nprocessor.ProcessErrorAsync += (args) =>\n{\n    Console.WriteLine($"Error in EventProcessorClient: {args.Exception.Message}");\n    return Task.CompletedTask;\n};\n\nawait processor.StartProcessingAsync();\nConsole.WriteLine("Processor started. Press any key to stop.");\nConsole.ReadKey();\nawait processor.StopProcessingAsync();` },
                        ]
                    },
                    {
                        id: 'service_bus',
                        name: 'Azure Service Bus',
                        tagline: 'Mensageria empresarial confiável',
                        domain: 'connectivity',
                        icon: '📨',
                        comparison_metrics: { 'Custo': 3, 'Escalabilidade': 4, 'Controle': 4, 'Estado': 5, 'Simplicidade': 3 },
                        details: {
                            overview: `<ul><li>Agente de mensagens corporativo totalmente gerenciado que permite a comunicação assínrona entre aplicativos e serviços.</li><li>Suporta filas (comunicação ponto a ponto) e tópicos (comunicação publish/subscribe).</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Desacoplamento de componentes de aplicativos.</li><li>Gerenciamento de transações distribuídas.</li><li>Comunicação entre microsserviços e processamento de mensagens de longa duração.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Mais complexo que as filas de armazenamento para casos de uso simples.</li><li>Custos associados ao volume de mensagens.</li></ul>`,
                        },
                        cli: [
                            { command: 'az servicebus namespace create --resource-group <rg_name> --name <namespace_name> --location <region> --sku Standard', description: 'Cria um namespace do Service Bus.' },
                            { command: 'az servicebus queue create --resource-group <rg_name> --namespace-name <namespace_name> --name <queue_name>', description: 'Cria uma fila do Service Bus.' },
                            { command: 'az servicebus topic create --resource-group <rg_name> --namespace-name <namespace_name> --name <topic_name>', description: 'Cria um tópico do Service Bus.' },
                        ],
                        sdk: [
                            { description: 'Enviar Mensagem para Fila (C#)', snippet: `using Azure.Messaging.ServiceBus;\n//...\nServiceBusClient client = new ServiceBusClient("YourConnectionString");\nServiceBusSender sender = client.CreateSender("myqueue");\nServiceBusMessage message = new ServiceBusMessage("Hello, Service Bus!");\nawait sender.SendMessageAsync(message);\nConsole.WriteLine("Message sent.");` },
                            { description: 'Receber Mensagem de Fila (C#)', snippet: `using Azure.Messaging.ServiceBus;\nusing System.Threading.Tasks;\n//...\nServiceBusClient client = new ServiceBusClient("YourConnectionString");\nServiceBusProcessor processor = client.CreateProcessor("myqueue", new ServiceBusProcessorOptions());\nprocessor.ProcessMessageAsync += async (args) =>\n{\n    string body = args.Message.Body.ToString();\n    Console.WriteLine($"Received: {body}");\n    await args.CompleteMessageAsync(args.Message);\n};\nprocessor.ProcessErrorAsync += (args) =>\n{\n    Console.WriteLine(args.Exception.ToString());\n    return Task.CompletedTask;\n};\nawait processor.StartProcessingAsync();` },
                        ]
                    },
                    {
                        id: 'queue_storage',
                        name: 'Azure Queue Storage',
                        tagline: 'Filas de mensagens simples e escaláveis',
                        domain: 'connectivity',
                        icon: '📤',
                        comparison_metrics: { 'Custo': 5, 'Escalabilidade': 5, 'Controle': 3, 'Estado': 5, 'Simplicidade': 5 },
                        details: {
                            overview: `<ul><li>Serviço de enfileiramento de mensagens simples e escalável, parte do Armazenamento do Azure.</li><li>Permite armazenar grandes números de mensagens que podem ser lidas por qualquer cliente autenticado.</li></ul>`,
                            useCases: `<p>Ideal para:</p><ul><li>Criação de filas de trabalho assíncronas.</li><li>Desacoplamento de componentes.</li><li>Processamento de tarefas em segundo plano.</li></ul>`,
                            limitations: `<p>Pontos a considerar:</p><ul><li>Mensagens com tamanho limitado (64 KB).</li><li>Não oferece recursos avançados como tópicos ou sessões.</li><li>Ideal para cenários de enfileiramento mais básicos.</li></ul>`,
                        },
                        cli: [
                            { command: 'az storage queue create --name <queue_name> --account-name <account_name>', description: 'Cria uma fila de armazenamento.' },
                            { command: 'az storage message put --queue-name <queue_name> --content "Hello Queue" --account-name <account_name>', description: 'Adiciona uma mensagem à fila.' },
                            { command: 'az storage message get --queue-name <queue_name> --account-name <account_name> --output table', description: 'Obtém mensagens da fila.' },
                        ],
                        sdk: [
                            { description: 'Adicionar Mensagem (C#)', snippet: `using Azure.Storage.Queues;\n//...\nQueueClient queueClient = new QueueClient("YourConnectionString", "myqueue");\nawait queueClient.CreateIfNotExistsAsync();\nawait queueClient.SendMessageAsync("Hello, Azure Queue!");\nConsole.WriteLine("Message sent to queue.");` },
                            { description: 'Receber e Excluir Mensagem (C#)', snippet: `using Azure.Storage.Queues;\nusing System.Threading.Tasks;\n//...\nQueueClient queueClient = new QueueClient("YourConnectionString", "myqueue");\nQueueMessage[] retrievedMessage = await queueClient.ReceiveMessagesAsync(1);\nif (retrievedMessage.Length > 0)\n{\n    Console.WriteLine($"Received: {retrievedMessage[0].MessageText}");\n    await queueClient.DeleteMessageAsync(retrievedMessage[0].MessageId, retrievedMessage[0].PopReceipt);\n    Console.WriteLine("Message deleted.");\n}` },
                        ]
                    }
                ];
                // Atribuição de quizQuestions aqui, sem 'let'
                quizQuestions = [
                    {
                        question: "Uma empresa usa Instâncias de Contêiner do Azure para um aplicativo. Você precisa garantir que os contêineres sejam reiniciados quando o processo terminar com um código de saída diferente de zero. O que você deve fazer?",
                        correctAnswer: "Defina uma política de reinicialização de contêiner de Always.",
                        explanation: "Este item testa o conhecimento do candidato sobre as políticas de reinicialização nas Instâncias de Contêiner do Azure. Os contêineres no grupo de contêineres são sempre reiniciados com uma política Always em vigor, independentemente do código de saída. A execução de contêineres usando uma identidade gerenciada simplificaria o acesso aos recursos externos do Azure, mas isso não tem efeito sobre quando um contêiner é reiniciado. Quando os processos no contêiner falharem (encerrando com um código de saída diferente de zero), eles não serão reiniciados e serão executados apenas uma vez no máximo. Os contêineres de inicialização destinam-se a executar a lógica de inicialização para contêineres de aplicativo, em execução até a conclusão antes do início dos contêineres do aplicativo.",
                        yourAnswer: "Defina uma política de reinicialização de contêiner de Always."
                    },
                    {
                        question: "Você está desenvolvendo um aplicativo .NET que inclui várias imagens de contêiner. O aplicativo será implantado nas Instâncias de Contêiner do Azure (ACI). Você precisa garantir que um compartilhamento de arquivos do Azure possa ser mapeado para cada contêiner do aplicativo. Qual configuração você deve usar?",
                        correctAnswer: "grupo de contêineres",
                        explanation: "Este item testa o conhecimento do candidato sobre a execução de contêineres usando as Instâncias de Contêiner do Azure (ACI). O recurso de nível superior na ACI é o grupo de contêineres. Um grupo de contêineres é uma coleção de contêineres que são agendados no mesmo computador host. Você pode especificar volumes externos para montar dentro de um grupo de contêineres. Você pode mapear esses volumes para caminhos específicos dentro dos contêineres individuais em um grupo. Um pod é um grupo de um ou mais contêineres com recursos de rede e armazenamento compartilhados e especificação de como executar os contêineres. Os pods podem ser usados no Serviço de Kubernetes do Azure, mas não na ACI. Contêineres confidenciais na ACI são usados para garantir a confidencialidade baseada em hardware. A ACI permite a implantação de instâncias de contêiner em uma rede virtual do Azure. Uma implantação de rede virtual não pode ser usada para mapear um compartilhamento de arquivos do Azure para cada contêiner em um cenário de vários contêineres.",
                        yourAnswer: "grupo de contêineres"
                    },
                    {
                        question: "Um grupo de contêineres nas Instâncias de Contêiner do Azure tem vários contêineres. Os contêineres devem ser reiniciados quando o processo executado no grupo de contêineres for encerrado devido a um erro. Você precisa definir a política de reinicialização para o grupo de contêineres. Qual comando da CLI do Azure você deve usar?",
                        correctAnswer: "az container create --resource-group myResourceGroup --name mycontainer --image mycontainerimage --restart-policy OnFailure",
                        explanation: "Este item testa o conhecimento do candidato sobre a execução de contêineres usando as Instâncias de Contêiner do Azure (ACI). As políticas de reinicialização configuráveis podem ser especificadas para um grupo de contêineres na ACI. Uma política de reinicialização configurável permite que você especifique que os contêineres são interrompidos quando seus processos são concluídos. Ao criar um grupo de contêineres na ACI, você pode especificar uma das três configurações de política de reinicialização: Always, Never e OnFailure. Se –restart-policy for mencionado como OnFailure, os contêineres no grupo de contêineres serão reiniciados somente quando o processo executado no contêiner falhar (quando ele terminar com um código de saída diferente de zero). Se –restart-policy for mencionado como Always, os contêineres no grupo de contêineres serão sempre reiniciados, independentemente do êxito ou falha da execução do processo em um contêiner. Se –restart-policy for mencionado como Nunca, os contêineres no grupo de contêineres só serão executados no máximo uma vez. O comando az container restart é usado para reiniciar todos os contêineres em um grupo de contêineres, não para definir uma política de reinicialização para um grupo de contêineres.",
                        yourAnswer: "az container create --resource-group myResourceGroup --name mycontainer --image mycontainerimage --restart-policy OnFailure"
                    },
                    {
                        question: "Sua empresa está desenvolvendo um aplicativo que inclui um serviço de API Web de back-end. A equipe de desenvolvimento decidiu usar os Aplicativos de Contêiner do Azure para hospedar a API. Eles têm um Dockerfile na raiz do repositório deles que define o aplicativo em contêineres. Você precisa implantar o aplicativo de contêiner usando o Dockerfile. O que você deve fazer?",
                        correctAnswer: "Use o comando az containerapp up com o parâmetro --source.",
                        explanation: "O comando az containerapp up com o parâmetro --source. cria e implanta o aplicativo de contêiner usando o Dockerfile na raiz do repositório.",
                        yourAnswer: "Use o comando az containerapp up com o parâmetro --source."
                    },
                    {
                        question: "Você desenvolve um aplicativo Web hospedado no recurso Aplicativos Web do Serviço de Aplicativo do Microsoft Azure. Você precisa habilitar e configurar o Cache Local do Serviço Web do Azure com 1,5 GB. Quais dois segmentos de código você deve usar? Cada resposta correta apresenta uma parte da solução.",
                        correctAnswer: "“WEBSITE_LOCAL_CACHE_OPTION”: “Always” e “WEBSITE_LOCAL_CACHE_SIZEINMB”: “1500”",
                        explanation: "Este item testa o conhecimento do candidato sobre a definição das configurações do recurso Aplicativos Web do Serviço de Aplicativo do Azure. Ao usar WEBSITE_LOCAL_CACHE_OPTION = Always, o cache local será habilitado. WEBSITE_LOCAL_CACHE_SIZEINMB configurará corretamente o cache local com 1,5 GB de tamanho. WEBSITE_LOCAL_CACHE_OPTION = Enable não é um valor válido. 1.5 não configurará 1,5 GB para o cache local.",
                        yourAnswer: "“WEBSITE_LOCAL_CACHE_OPTION”: “Always” e “WEBSITE_LOCAL_CACHE_SIZEINMB”: “1500”"
                    },
                    {
                        question: "Você cria um aplicativo Web do Azure localmente. O aplicativo Web consiste em um pacote ZIP. Você precisa implantar o aplicativo Web usando a CLI do Azure. A implantação deve reduzir a probabilidade de arquivos bloqueados. O que você deve fazer?",
                        correctAnswer: "Execute az webapp deploy em um slot de preparo com a troca automática habilitada.",
                        explanation: "Este item testa o conhecimento do candidato sobre a implantação de Aplicativos Web do Azure usando a CLI do Azure. O uso de um slot de produção e preparo com a troca automática habilitada reduz a probabilidade de arquivos bloqueados. Se –clean true for usada, a pasta de destino será limpa, mas isso não terá efeito sobre a probabilidade de arquivos bloqueados. É bom reiniciar o aplicativo após a implantação. Isso, no entanto, é o comportamento padrão de uma implantação ZIP e não tem nenhum efeito sobre a probabilidade reduzida de arquivos bloqueados durante a implantação. O parâmetro --timeout não tem efeito sobre a probabilidade de arquivos bloqueados.",
                        yourAnswer: "Execute az webapp deploy em um slot de preparo com a troca automática habilitada."
                    },
                    {
                        question: "Você gerencia os slots de implantação de preparo e produção de um aplicativo Web do Serviço de Aplicativo do Azure chamado app1. Você precisa garantir que uma cadeia de conexão não seja trocada quando a troca for executada. Qual configuração você deve usar?",
                        correctAnswer: "Configuração do slot de implantação",
                        explanation: "Este item testa o conhecimento do candidato sobre a implantação de código no Serviço de Aplicativo do Azure, que faz parte da criação de Aplicativos Web do Serviço de Aplicativo do Azure. Marcar uma configuração como uma configuração de slot de implantação a mantém aderida a esse slot de implantação. Por exemplo, uma configuração de aplicativo marcada como uma configuração de slot de implantação no app1 sempre ficará com o app1 e nunca será movida para app1/preparo durante uma troca. A configuração do Centro de Implantação é usada para configurar a implantação contínua e a implantação manual. A identidade gerenciada fornece uma identidade para os aplicativos usarem ao conectarem-se a recursos que suportam a autenticação do Microsoft Entra ID. A escala vertical garantirá que o aplicativo Web tenha o direito de obter CPU, memória, espaço em disco e recursos extras, como máquinas virtuais dedicadas, domínios e certificados personalizados, slots de preparo e colocação em escala automática. O Centro de Implantação, a Identidade Gerenciada e a Escala Vertical não podem ser usados para garantir que uma cadeia de conexão não seja trocada quando a troca é executada.",
                        yourAnswer: "Configuração do slot de implantação"
                    },
                    {
                        question: "Você está desenvolvendo um aplicativo Web do Linux no Serviço de Aplicativo do Azure. Você precisa implantar o aplicativo Web no ambiente de produção com base nos seguintes requisitos: As alterações de aplicativo devem ser validadas em um ambiente idêntico ao ambiente de produção antes de mover o aplicativo para o ambiente de produção. O tempo de inatividade deve ser eliminado quando o aplicativo é implantado no ambiente de produção. O que você deve usar?",
                        correctAnswer: "Slots de implantação",
                        explanation: "Este item testa o conhecimento do candidato sobre quando usar slots de implantação. Os slots de implantação são aplicativos dinâmicos com nomes de host exclusivos, que permitem a troca de configuração e conteúdo entre eles. O dimensionamento automático é um recurso que permite adicionar mais capacidade a um ambiente de hospedagem de aplicativo do Azure Functions. Essa capacidade pode ser adicionada a um ambiente de hospedagem individual (por exemplo, escalar verticalmente ou adicionar memória ou CPU) ou adicionar mais hosts (colocação em escala horizontal). O colocação em escala pode ser disparado com base em um agendamento ou ao violar limites definidos para determinadas métricas. As conexões híbridas estão disponíveis para consumir aplicativos locais sem a necessidade de expô-las à Internet. A clonagem de aplicativo é um processo para obter um aplicativo existente e copiá-lo para outro destino, que pode ser um novo aplicativo ou um slot de implantação, por exemplo. No entanto, isso não tem suporte em aplicativos Linux.",
                        yourAnswer: "Slots de implantação"
                    },
                    {
                        question: "Você desenvolve um aplicativo do Serviço de Aplicativo hospedado na Plataforma Windows. Os usuários relatam que o aplicativo está falhando. Você precisa começar a solucionar problemas do aplicativo inspecionando uma cópia da página retornada quando o código de retorno HTTP for maior que 400. Qual tipo de log você deve examinar?",
                        correctAnswer: "erro detalhado",
                        explanation: "Este item testa o conhecimento do candidato sobre como usar logs para solucionar problemas de aplicativos Web. O log de erros detalhado contém cópias das páginas de erro, produzidas em resposta a códigos HTTP maiores que 400, que teriam sido enviadas aos clientes. Essas páginas não são enviadas por motivos de segurança. O log do servidor Web mostra informações sobre a solicitação HTTP bruta, como método, bytes e agente de usuário cliente. O log do aplicativo é específico do aplicativo, registrando informações que o código do aplicativo ou os componentes usados pelo aplicativo gravam. O log de implantação armazena informações para diagnosticar os motivos de uma implantação com falha.",
                        yourAnswer: "erro detalhado"
                    },
                    {
                        question: "Você planeja criar um aplicativo do Azure Functions chamado app1. Você precisa garantir que o app1 atenda aos seguintes requisitos: Dar suporte à colocação em escala automática. Ter um comportamento de colocação em escala baseada em evento. Fornecer um modelo de preço sem servidor. Qual plano de hospedagem você deve usar?",
                        correctAnswer: "Consumo",
                        explanation: "Este item testa o conhecimento do candidato de selecionar o plano de hospedagem apropriado, que faz parte da implementação do Azure Functions. O plano de hospedagem de Consumo atende a todos os requisitos. Ele dá suporte à colocação em escala automática, tem comportamento de colocação em escala baseado em eventos e fornece um modelo de preços sem servidor. O Serviço de Aplicativo, o Ambiente do Serviço de Aplicativo e os planos de hospedagem do Functions Premium dão suporte à colocação em escala automática, mas não fornecem o modelo de preços sem servidor. Seu comportamento de colocação em escala não é baseado em evento, mas em desempenho.",
                        yourAnswer: "Consumo"
                    },
                    {
                        question: "Você tem um Azure Key Vault chamado MyVault. Você precisa alterar as configurações do Serviço de Aplicativo do Azure usando uma referência de cofre de chaves para acessar um segredo chamado MyConnection do MyVault. Qual segmento de código você deve usar?",
                        correctAnswer: "@Microsoft.KeyVault(SecretName=MyConnection;VaultName=MyVault)",
                        explanation: "Este item testa o conhecimento do candidato sobre a recuperação de segredos do Key Vault no Azure Functions. O segmento @Microsoft.KeyVault(SecretName=MyConnection;VaultName=MyVault) de código lê o segredo do Key Vault. O segmento de código que inclui Secret us um parâmetro inválido. O segmento de código que inclui Secret e Vault usa parâmetros inválidos. O segmento de código que inclui SecretName e Vault usa parâmetros inválidos.",
                        yourAnswer: "@Microsoft.KeyVault(SecretName=MyConnection;VaultName=MyVault)"
                    },
                    {
                        question: "Você planeja criar um aplicativo do Azure Functions baseado em script em C#. Você precisa configurar o gatilho e as associações para as funções do aplicativo do Azure Functions. O que você deve fazer?",
                        correctAnswer: "Crie um arquivo function.json para cada função.",
                        explanation: "Este item testa o conhecimento do candidato sobre a configuração de gatilhos e associações. Ao usar linguagens de script, como script C#, o arquivo function.json para cada função contém seus gatilhos e associações e precisa ser criado explicitamente. O host.json de arquivo tem configurações específicas de runtime, não definições de gatilhos e associações. Métodos de decoração e parâmetros de decoração são usados para definir gatilhos e associações ao usar idiomas compilados, não scripts.",
                        yourAnswer: "Crie um arquivo function.json para cada função."
                    },
                    {
                        question: "Uma empresa planeja criar um aplicativo do Azure Functions. Você precisa recomendar uma solução para atender aos seguintes requisitos: Executa várias funções simultaneamente. Executa a agregação nos resultados das funções. Evita inícios frios. Minimiza os custos. Quais dois componentes você deve recomendar? Cada resposta correta apresenta parte da solução",
                        correctAnswer: "O plano Premium e Padrão fan-out/fan-in",
                        explanation: "Este item testa o conhecimento do candidato sobre o Azure Durable Functions e planos de hospedagem. O plano Premium evita inícios frios e oferece duração de execução ilimitada. O padrão fan-out/fan-in permite que várias funções sejam executadas em paralelo, aguardando a conclusão de todas as funções. Frequentemente, algum trabalho de agregação é feito nos resultados retornados pelas funções. O plano de Consumo evita pagar pelo tempo ocioso, mas pode enfrentar inícios frios. Além disso, cada execução de função é limitada a 10 minutos. O padrão de encadeamento de funções é uma sequência de funções que são executadas em uma ordem específica. Nesse padrão, a saída de uma função é aplicada à entrada de outra função.",
                        yourAnswer: "O plano Premium e Padrão fan-out/fan-in"
                    },
                    {
                        question: "Você cria uma rotina de lote usando um gatilho de temporizador no Azure Functions. Você precisa configurar a rotina do lote para ser executada a cada 15 minutos, de segunda a sexta. Qual segmento de código você deve usar?",
                        correctAnswer: "[Function(nameof(TimerTriggerCSharp)] [FixedDelayRetry(5, \"00:00:10\")] public static void Run([TimerTrigger(\"0 */15 * * * 1-5\")] TimerInfo myTimer, FunctionContext contexto) { var log = contexto.GetLogger(nameof(TimerFunction)); se (myTimer.IsPastDue) { log.LogInformation(\"O temporizador está atrasado!\"); } Log.LogInformation($\"Função de gatilho do Temporizador em C# executada em: {DateTime.Now}\"); }",
                        explanation: "Este item testa o conhecimento do candidato sobre trabalhar com gatilhos de temporizador no Azure Functions. O segmento de código que inclui Run([TimerTrigger(\"0 */15 * * * 1-5\") executa a função a cada 15 minutos de segunda a sexta-feira. O segmento de código que inclui Run([TimerTrigger(\"*/15 * * * 0-4\") está com a segunda parte ausente e não está utilizando o intervalo correto para os dias da semana. O segmento de código que inclui Run([TimerTrigger(\"0 15 * * * \") executa somente uma vez às 15:00. O segmento de código que inclui Run([TimerTrigger(\"* 15 * * 1-5\") está faltando o atributo de segundos e a parte de etapa ('/') para os minutos.",
                        yourAnswer: "[Function(nameof(TimerTriggerCSharp)] [FixedDelayRetry(5, \"00:00:10\")] public static void Run([TimerTrigger(\"0 */15 * * * 1-5\")] TimerInfo myTimer, FunctionContext contexto) { var log = contexto.GetLogger(nameof(TimerFunction)); se (myTimer.IsPastDue) { log.LogInformation(\"O temporizador está atrasado!\"); } Log.LogInformation($\"Função de gatilho do Temporizador em C# executada em: {DateTime.Now}\"); }"
                    },
                    {
                        question: "Você está desenvolvendo uma API sem servidor usando o Azure Functions. Espera-se que a API lide com um grande número de solicitações HTTP e faça solicitações de saída para um serviço de terceiros. O serviço de terceiros tem um limite de taxa no número de solicitações que pode manipular por minuto. Você precisa garantir que a Função do Azure não exceda o limite de taxa do serviço de terceiros e gerencie a utilização de recursos de maneira eficaz. Cada resposta correta apresenta uma parte da solução. Quais são as duas ações que você deve executar?",
                        correctAnswer: "Defina a propriedade 'maxConcurrentRequests' no arquivo host.json para limitar o número de execuções paralelas. e Defina a propriedade 'maxOutstandingRequests' no arquivo host.json para limitar o número de solicitações pendentes a qualquer momento.",
                        explanation: "Definir a propriedade 'maxConcurrentRequests' no arquivo host.json limitará o número de funções HTTP executadas em paralelo, o que pode ajudar a gerenciar a utilização de recursos e evitar exceder o limite de taxa do serviço de terceiros. A propriedade 'maxOutstandingRequests' limita o número de solicitações pendentes que são mantidas a qualquer momento, incluindo solicitações enfileiradas e execuções em andamento, que também podem ajudar a gerenciar a utilização de recursos. Habilitar a propriedade 'dynamicThrottlesEnabled' não ajudaria nesse cenário, pois rejeita solicitações com base em contadores de desempenho do sistema, não com base no limite de taxa de um serviço de terceiros. A propriedade 'hsts' é usada para impor o comportamento HSTS (Segurança de Transporte Estrito HTTP) e não está relacionada ao gerenciamento de utilização de recursos ou limitação de taxa. A propriedade 'routePrefix' é usada para definir o prefixo de rota para todas as rotas e não afeta a utilização de recursos ou a limitação de taxa.",
                        yourAnswer: "Defina a propriedade 'maxConcurrentRequests' no arquivo host.json para limitar o número de execuções paralelas. e Defina a propriedade 'maxOutstandingRequests' no arquivo host.json para limitar o número de solicitações pendentes a qualquer momento."
                    },
                    {
                        question: "Você gerencia uma implantação de várias regiões de uma conta do Azure Cosmos DB chamada account1. Você precisa configurar o nível de consistência padrão para account1. O nível de consistência deve maximizar a taxa de transferência e minimizar a latência para operações de gravação. Qual nível de consistência você deve usar?",
                        correctAnswer: "possível",
                        explanation: "Este item testa o conhecimento do candidato de selecionar o nível de consistência, que faz parte do desenvolvimento de soluções do Azure Cosmos DB. O nível de consistência eventual maximiza a taxa de transferência e minimiza a latência. O nível de consistência de desatualização limitada fornece menor taxa de transferência e maior latência em comparação com as opções de resposta restantes. O nível de consistência de prefixo consistente fornece maior taxa de transferência e menor latência para operações de gravação do que o nível de consistência da sessão, mas taxa de transferência mais baixa e latência maior do que os níveis de consistência eventual. O nível de consistência da sessão fornece maior taxa de transferência e menor latência para operações de gravação do que o nível de consistência de desatualização limitada, mas taxa de transferência mais baixa e latência maior do que os níveis de consistência de prefixo eventuais e consistentes.",
                        yourAnswer: "possível"
                    },
                    {
                        question: "Você gerencia um banco de dados do Azure Cosmos DB chamado database1. Você precisa ler itens do banco de dados sem nenhuma garantia de ordenação e garantir a maior disponibilidade. Qual nível de consistência você deve usar?",
                        correctAnswer: "possível",
                        explanation: "Este item testa o conhecimento do candidato sobre os níveis de consistência no Azure Cosmos DB, que faz parte do desenvolvimento de soluções que usam o Armazenamento do Microsoft Azure Cosmos DB. A consistência eventual tem a consistência mais flexível e confirma qualquer operação de gravação no primário imediatamente. Isso fornecerá a maior disponibilidade e a menor consistência. A coerência forte oferece uma garantia de transação atômica. Transação atômica se refere ao fornecimento de solicitações simultaneamente. Os usuários sempre terão a garantia de ler a última gravação confirmada. A consistência forte sofre com a redução da disponibilidade. A consistência de desatualização limitada não fornecerá a maior disponibilidade. Quando um cliente executa operações de leitura em uma região que aceita gravações, as garantias fornecidas pela consistência de desatualização limitada e consistência forte são idênticas. A consistência da sessão garante que todas as operações de leitura e gravação sejam consistentes em uma sessão de usuário. Como o aplicativo não requer garantia de consistência, esse nível de consistência não é apropriado.",
                        yourAnswer: "possível"
                    },
                    {
                        question: "Você tem um aplicativo que grava dados no Azure Cosmos DB. O aplicativo deve oferecer leituras monotônicas, sem garantia de que o valor lido seja o último valor gravado. Você precisa configurar o nível de consistência. Qual nível de consistência você deve usar?",
                        correctAnswer: "sessão",
                        explanation: "Este item testa o conhecimento do candidato sobre os níveis de consistência do Azure Cosmos DB. A consistência da sessão oferece todas as garantias listadas. Ela fornece latências de gravação, disponibilidade e taxa de transferência de leitura comparáveis à coerência eventual. Ele também fornece as garantias de consistência que atendem às necessidades de aplicativos gravados para operar no contexto de um usuário. A consistência forte tem leituras garantidas para retornar a versão confirmada mais recente de um item. Um cliente nunca vê uma gravação não comprometida ou parcial. Os usuários têm a garantia de ler a gravação confirmada mais recente. Ele tem a maior latência de gravação e a menor taxa de transferência de leitura de todos os níveis de consistência. Na coerência desatualização limitada, as leituras têm a garantia de honrar a garantia de prefixo consistente. Ele deve ser usado quando há a necessidade de latências de gravação baixas, mas exige uma garantia de ordem global total. Em consistência eventual, não há garantia de ordenação para leituras. Na ausência de qualquer gravação adicional, as réplicas eventualmente convergem. É a forma mais fraca de consistência porque um cliente pode ler valores mais antigos do que os que ele havia lido antes. A consistência eventual é ideal quando o aplicativo não exige garantias de ordenação.",
                        yourAnswer: "sessão"
                    },
                    {
                        question: "Você tem blobs no Armazenamento de Blobs do Azure. Os blobs armazenam imagens. Você precisa registrar as informações de localização e condição climática de quando as fotos foram tiradas. Você deve garantir que possa usar até 2.000 caracteres ao gravar as informações. O que você deve fazer?",
                        correctAnswer: "Use cabeçalhos de metadados definidos com uma solicitação PUT.",
                        explanation: "Este item testa o conhecimento do candidato sobre a estruturação de dados para o armazenamento de blobs. Os metadados são a maneira adequada de definir esse tipo de dados, permitindo modificações independentes e dando suporte a até 8 KB no tamanho total. O verbo HTTP para definir metadados é um PUT e esse é o formato correto para definir valores de metadados. O tamanho máximo de um nome de blob é de 1.024 caracteres. Além disso, essa não é uma abordagem ideal porque os metadados podem ser obtidos e definidos de forma independente, mantendo o mesmo nome de arquivo. Os metadados são a maneira adequada de definir esse tipo de dados, permitindo modificações independentes e dando suporte a até 8 KB no tamanho total. Mas o verbo HTTP para definir metadados é PUT, não POST. A combinação de locais e tipos de clima pode ser potencialmente ilimitada, e os nomes de contêiner são limitados a 63 caracteres.",
                        yourAnswer: "Use cabeçalhos de metadados definidos com uma solicitação PUT."
                    },
                    {
                        question: "Você tem uma política de ciclo de vida de Armazenamento do Microsoft Azure para blobs de blocos. Você precisa criar uma regra de filtro prefixMatch que conterá uma matriz de cadeias de caracteres para que os prefixos sejam correspondidos. Qual deve ser o primeiro elemento da cadeia de caracteres de prefixo?",
                        correctAnswer: "um nome de contêiner",
                        explanation: "Este item testa o conhecimento do candidato sobre a configuração do filtro prefixMatch, que é uma parte essencial da configuração da política de armazenamento e faz parte do desenvolvimento da solução para o armazenamento de blobs. Ao criar uma regra de filtro prefixMatch para uma política de ciclo de vida de Armazenamento do Microsoft Azure para blobs de blocos, o primeiro elemento da cadeia de caracteres de prefixo deve ser um nome de contêiner, não uma marca de índice de blob de blocos, um nome de blob de blocos ou um nome de conta de armazenamento.",
                        yourAnswer: "um nome de contêiner"
                    },
                    {
                        question: "Você cria a política de retenção a seguir. (Os números de linha são incluídos somente para referência.) Você precisará fazer a transição de blobs na camada de acesso frequente para uma camada online se os blobs não tiverem sido modificados em mais de 90 dias. Qual segmento de código você deve adicionar à linha 14?",
                        correctAnswer: "\"tierToCool\": { \"daysAfterModificationGreaterThan\": 90 }",
                        explanation: "Este item testa o conhecimento do candidato sobre as camadas de blob. O segmento de código \"tierToCool\": { \"daysAfterModificationGreaterThan\": 90 } move os blobs não modificados após 90 dias para a camada Cool, conforme definido pelo requisito. Os segmentos de código que incluem \"tierToArchive\": mover os blobs para a camada arquivo morto, que não é uma camada de acesso online; é uma camada offline. O segmento de código \"tierToCool\": { \"daysAfterCreationGreaterThan\": 90 } move os blobs para a camada de acesso esporádico 90 dias após a criação, o que não atende ao requisito de mover blobs após 90 dias sem modificação.",
                        yourAnswer: "\"tierToCool\": { \"daysAfterModificationGreaterThan\": 90 }"
                    },
                    {
                        question: "Você precisa reidratar um blob armazenado na camada de Arquivos alterando a camada de acesso. Qual blob de destino você deve usar?",
                        correctAnswer: "Um blob na camada de acesso esporádico na mesma região.",
                        explanation: "Este item testa o conhecimento do candidato sobre reidratação de blobs. Os blobs na camada arquivo morto podem ser reidratados apenas para camadas online (ou seja, Cool ou Hot). O destino pode ser qualquer conta de armazenamento na mesma região.",
                        yourAnswer: "Um blob na camada de acesso esporádico na mesma região."
                    },
                    {
                        question: "Você está desenvolvendo um aplicativo. Você precisa definir as propriedades HTTP padrão de contêineres no Armazenamento de Blobs do Azure. Quais são as duas propriedades HTTP que você pode definir? Cada resposta correta apresenta uma parte da solução.",
                        correctAnswer: "Etag e Last-Modified",
                        explanation: "Este item testa o conhecimento do candidato sobre como definir e recuperar propriedades e metadados. Os metadados nos objetos do Armazenamento do Microsoft Azure são definidos por meio de cabeçalhos que começam com x-ms-meta-. Algumas propriedades HTTP padrão também estão disponíveis para objetos e contêineres. As duas únicas propriedades HTTP disponíveis para contêineres são ETag e Last-Modified. Última modificação, controle de cache, origem e intervalo são propriedades disponíveis apenas para blobs.",
                        yourAnswer: "Etag e Last-Modified"
                    },
                    {
                        question: "Você deve planejar usar o Microsoft Graph para recuperar uma lista de usuários em um locatário do Microsoft Entra ID. Você precisa otimizar os resultados da consulta. Quais duas opções de consulta você deve usar? Cada resposta correta apresenta uma parte da solução.",
                        correctAnswer: "$filter e $select",
                        explanation: "Este item testa o conhecimento do candidato sobre as opções de consulta do Microsoft Graph. A opção de consulta $filter deve ser usada para limitar os resultados retornados. A opção de consulta $select limita os atributos projetados do conjunto de resultados, tornando a consulta mais eficiente. A opção de consulta $count destina-se a recuperar a contagem total de recursos correspondentes.A opção de consulta $expand é usada para recuperar recursos relacionados.",
                        yourAnswer: "$filter e $select"
                    },
                    {
                        question: "Você tem uma conta de Armazenamento do Microsoft Azure. Você precisa fornecer aos usuários externos a capacidade de criar e atualizar blobs. Qual valor de enumeração de BlobSasPermissions você deve usar?",
                        correctAnswer: "Gravar",
                        explanation: "Este item testa o conhecimento do candidato sobre como criar e implementar blobs. A permissão de gravação permitirá que os usuários criem e atualizem blobs. A permissão Adicionar só é aplicável para blobs de acréscimo. A permissão Criar só permite que os usuários criem blobs. Ela não permite que os usuários atualizem blobs. A permissão de leitura não permite que os usuários criem e atualizem blobs.",
                        yourAnswer: "Gravar"
                    },
                    {
                        question: "Você desenvolve um aplicativo. O aplicativo será acessado por um fornecedor. O fornecedor requer uma Assinatura de Acesso Compartilhado (SAS) para acessar os serviços do Azure na assinatura da sua empresa. Você precisa proteger a SAS. Quais são as três ações que você deve executar? Cada resposta correta apresenta uma solução completa.",
                        correctAnswer: "Sempre usar HTTPS. Use os logs do Azure Monitor e do Armazenamento do Microsoft Azure para monitorar o aplicativo. Defina uma política de acesso armazenada para uma SAS de serviço.",
                        explanation: "Este item testa o conhecimento do candidato sobre como criar e implementar assinaturas de acesso compartilhado (SAS). A recomendação de sempre usar HTTPS é válida e deve ser seguida. O log do Azure Monitor e da análise de armazenamento deve ser usado para observar qualquer pico nesses tipos de falhas de autorização. As políticas de acesso armazenadas darão a opção de revogar permissões para uma SAS de serviço sem precisar regenerar as chaves da conta de armazenamento. Uma prática recomendada de segurança consiste em fornecer os privilégios mínimos necessários a um usuário. É melhor usar tempos de expiração de curto prazo em um serviço SAS ad hoc ou SAS de conta para que, mesmo que uma SAS esteja comprometida, ela seja válida apenas por um curto período de tempo.",
                        yourAnswer: "Sempre usar HTTPS. Use os logs do Azure Monitor e do Armazenamento do Microsoft Azure para monitorar o aplicativo. Defina uma política de acesso armazenada para uma SAS de serviço."
                    },
                    {
                        question: "Você planeja permitir que um usuário crie uma identidade gerenciada para uma máquina virtual (VM) do Azure. Você precisa garantir que os seguintes requisitos sejam atendidos: A conta de usuário deve ter permissões suficientes para criar a identidade gerenciada. O princípio de privilégio mínimo deve ser usado. Qual função de permissão você deve atribuir?",
                        correctAnswer: "Colaborador de Máquina Virtual",
                        explanation: "Este item testa o conhecimento do candidato sobre o princípio do privilégio mínimo, que é uma parte essencial da implementação de soluções de nuvem seguras. Colaborador de Máquina Virtual é a função interna menos privilegiada necessária para criar uma identidade gerenciada para uma VM do Azure. O Logon do Administrador de Máquina Virtual não é suficiente para criar uma identidade gerenciada para uma VM do Azure. O Administrador Global e o Administrador de Segurança têm permissões excessivas no Microsoft Entra ID, o que não segue o princípio de privilégios mínimos. O Administrador Global e o Administrador de Segurança não fornecem permissões suficientes para os recursos do Azure.",
                        yourAnswer: "Colaborador de Máquina Virtual"
                    },
                    {
                        question: "Você precisa agrupar chaves na Configuração de Aplicativos do Azure. Quais são as duas maneiras possíveis de atingir essa meta? Cada resposta correta apresenta uma solução completa.",
                        correctAnswer: "Organize as chaves usando prefixos de chave. e Organize as chaves usando rótulos.",
                        explanation: "Este item testa o conhecimento do candidato sobre as práticas recomendadas ao trabalhar com chaves na Configuração de Aplicativos do Azure. Os prefixos de chave são as partes iniciais das chaves. Um conjunto de chaves pode ser agrupado usando o mesmo prefixo em nomes. Os Rótulos são um atributo nas chaves. Os rótulos são usados para criar variantes de uma chave. Por exemplo, os rótulos podem ser atribuídos a várias versões de uma chave. Autorizar o controle de acesso baseado em função para ler a Configuração de Aplicativos do Azure não é uma maneira válida de agrupar chaves. Autorizar uma identidade gerenciada para ler a Configuração de Aplicativos do Azure não é uma maneira válida de agrupar chaves.",
                        yourAnswer: "Organize as chaves usando prefixos de chave. e Organize as chaves usando rótulos."
                    },
                    {
                        question: "Você gerencia um aplicativo Web do Serviço de Aplicativo do Azure chamado app1 e um Azure Key Vault chamado vault1. Você precisa garantir que o app1 possa autenticar e conduzir operações com o vault1 sem gerenciar a rotação de um segredo. O recurso necessário para implementar a solução deve ser excluído automaticamente quando o aplicativo for excluído Qual método de autenticação você deve usar para o app1?",
                        correctAnswer: "identidade gerenciada atribuída ao sistema",
                        explanation: "Este item testa o conhecimento do candidato sobre a implementação do Azure Key Vault, que faz parte da implementação de soluções de Nuvem Segura. Uma identidade gerenciada atribuída pelo sistema pode ser usada para garantir que o app1 possa autenticar e executar operações com o vault1 sem gerenciar a rotação de um segredo. Uma identidade gerenciada atribuída pelo usuário pode ser usada para garantir que o app1 possa autenticar e executar operações com o vault1, mas a rotação de segredo precisa ser gerenciada. Uma entidade de serviço e um segredo podem ser usados para autenticar no cofre de chaves, mas é difícil girar automaticamente o segredo usado para autenticar no cofre de chaves. Uma entidade de serviço e um certificado associado com acesso ao cofre de chaves podem ser usados para autenticação, mas exigiriam o gerenciamento da rotação de um segredo.",
                        yourAnswer: "identidade gerenciada atribuída ao sistema"
                    },
                    {
                        question: "Você planeja criar uma hierarquia de namespace de chave na Configuração de Aplicativos do Azure. Você precisa separar nomes de chave individuais. Qual caractere você deve usar?",
                        correctAnswer: ":",
                        explanation: "Este item testa o conhecimento do candidato de configurar a hierarquia de namespace de chave da Configuração de Aplicativos, que faz parte da implementação de soluções de nuvem seguras. O caractere de dois-pontos (:) é usado para separar nomes de chaves individuais ao criar uma hierarquia de namespace na Configuração de Aplicativos do Azure. O caractere asterisco (*) é um dos caracteres reservados na Configuração de Aplicativos do Azure, portanto, ele não pode ser usado para separar nomes de chaves individuais ao criar uma hierarquia de namespace na Configuração de Aplicativos do Azure. O caractere de vírgula (,) é um dos caracteres reservados na Configuração de Aplicativos do Azure, portanto, ele não pode ser usado para separar nomes de chaves individuais ao criar uma hierarquia de namespace na Configuração de Aplicativos do Azure. O caractere de barra invertida () é um dos caracteres reservados na Configuração de Aplicativos do Azure, portanto, ele não pode ser usado para separar nomes de chaves individuais ao criar uma hierarquia de namespace na Configuração de Aplicativos do Azure.",
                        yourAnswer: ":"
                    },
                    {
                        question: "Uma empresa planeja usar a Configuração de Aplicativos do Azure para sinalizadores de recursos em um aplicativo. A empresa tem os seguintes requisitos de criptografia: Chaves gerenciadas pelo cliente. Chaves protegidas por HSM (módulo de segurança de hardware). Você precisa recomendar camadas de serviço. Quais duas camadas você deve recomendar? Cada resposta correta apresenta uma parte da solução.",
                        correctAnswer: "Camada Standard da Configuração de Aplicativos do Azure e Camada Premium do Azure Key Vault",
                        explanation: "Este item testa o conhecimento do candidato sobre as camadas de serviço para a Configuração de Aplicativos do Azure e o Azure Key Vault. A camada Standard de Configuração de Aplicativo deve ser usada para que as chaves gerenciadas pelo cliente sejam usadas na Configuração de Aplicativos. A camada Premium do Key Vault é necessária para dar suporte a chaves protegidas por HSM. A camada Gratuita de Configuração de Aplicativos não permite o uso de chaves gerenciadas pelo cliente. A camada Standard do Key Vault não dá suporte a chaves protegidas por HSM.",
                        yourAnswer: "Camada Standard da Configuração de Aplicativos do Azure e Camada Premium do Azure Key Vault"
                    },
                    {
                        question: "Você está desenvolvendo uma solução que armazena segredos em um Azure Key Vault chamado myvault. Você precisa recuperar o valor de um segredo chamado mysecret armazenado em myvault. Qual comando da CLI você deve usar?",
                        correctAnswer: "az keyvault secret show --name mysecret --vault-name myvault",
                        explanation: "Este item testa o conhecimento do candidato sobre o desenvolvimento de código que usa chaves, segredos e certificados armazenados no Azure Key Vault. O comando az keyvault da CLI oferece vários comandos para trabalhar com segredos. Os comandos mais usados são set para armazenar um segredo e show para obter o valor do segredo. Ao usar esses comandos, deve-se especificar uma ID que contenha a identificação completa do segredo (no formato https://keyvaultname.vault.azure.net/secrets/secret-name/secret-version)) ou o nome do segredo e o nome do cofre.",
                        yourAnswer: "az keyvault secret show --name mysecret --vault-name myvault"
                    },
                    {
                        question: "Você tem a tarefa de aprimorar a segurança de um aplicativo Web do Azure existente. Atualmente, o aplicativo armazena dados de configuração confidenciais, como cadeias de conexão e chaves de API em seu código, o que gerou preocupações de segurança. Você precisa proteger os dados de configuração do aplicativo para evitar acesso não autorizado e possíveis violações de dados, garantindo acesso contínuo ao próprio aplicativo. Quais são as duas opções que podem atingir esse objetivo? (Escolha duas.)",
                        correctAnswer: "Migre os dados de configuração confidenciais para o Azure Key Vault e utilize identidades gerenciadas para acessar os segredos com segurança. e Armazene os dados de configuração confidenciais na Configuração de Aplicativos do Azure e restrinja o acesso usando o RBAC (controle de acesso baseado em função) do Azure.",
                        explanation: "Armazenar dados de configuração confidenciais na Configuração de Aplicativos do Azure e restringir o acesso com o RBAC do Azure é um método seguro para gerenciar as configurações do aplicativo, mantendo o controle sobre quem pode acessar os dados. A migração de dados confidenciais para o Azure Key Vault e o uso de identidades gerenciadas permitem que o aplicativo se autentique em serviços que dão suporte à autenticação do Azure AD sem precisar de credenciais no código, o que aumenta a segurança. Criptografar os dados e armazená-los no código do aplicativo não segue as práticas recomendadas de segurança, pois eles ainda residem na base de código e podem ser expostos. O armazenamento de dados confidenciais em um repositório privado do GitHub não é seguro, pois depende de credenciais do GitHub, que, se comprometidas, podem levar a acesso não autorizado.",
                        yourAnswer: "Migre os dados de configuração confidenciais para o Azure Key Vault e utilize identidades gerenciadas para acessar os segredos com segurança. e Armazene os dados de configuração confidenciais na Configuração de Aplicativos do Azure e restrinja o acesso usando o RBAC (controle de acesso baseado em função) do Azure."
                    },
                    {
                        question: "Você tem um aplicativo Web do Azure que ocasionalmente experimenta tempos de resposta altos. Você precisa ser notificado quando o tempo de resposta exceder um determinado limite. O que você deve fazer?",
                        correctAnswer: "Implementar alertas e testes Web do Application Insights.",
                        explanation: "O Application Insights permite que você crie testes da Web que simulam interações do usuário com seu aplicativo e, em seguida, configure alertas com base nos resultados desses testes. Os alertas do Azure Monitor Resource Health são usados para monitoramento de infraestrutura, não para desempenho de aplicativos. A Integridade do Serviço do Azure fornece informações sobre problemas de serviço do Azure e manutenção planejada, não o desempenho do aplicativo. O Assistente do Azure fornece recomendações de práticas recomendadas, não alertas de desempenho do aplicativo.",
                        yourAnswer: "Implementar alertas e testes Web do Application Insights."
                    },
                    {
                        question: "Sua equipe está desenvolvendo um novo recurso para um aplicativo existente baseado no Azure que depende muito do processamento de dados em tempo real. O recurso envolve a integração de vários serviços do Azure e APIs de terceiros. Você precisa criar uma estratégia para garantir que a integração desses serviços não introduza problemas ou falhas de desempenho. Você precisa projetar a solução de monitoramento para detectar e resolver possíveis problemas. O que você deve fazer?",
                        correctAnswer: "Use Métricas Dinâmicas no Application Insights para observar a atividade do aplicativo implantado em tempo real.",
                        explanation: "A opção D está correta porque o Live Metrics fornece observação em tempo real da atividade do aplicativo, permitindo detecção e resposta imediatas a problemas de desempenho. A opção C está incorreta, pois as verificações noturnas podem não ser suficientes para as necessidades de processamento de dados em tempo real. A opção A está incorreta porque um único teste de disponibilidade não fornece monitoramento abrangente de todos os serviços integrados. A opção B está incorreta, pois a revisão manual dos logs não é eficiente para monitoramento em tempo real e pode atrasar a resposta aos problemas.",
                        yourAnswer: "Use Métricas Dinâmicas no Application Insights para observar a atividade do aplicativo implantado em tempo real."
                    },
                    {
                        question: "Uma plataforma de comércio eletrônico está planejando expandir seus serviços globalmente. A plataforma está hospedada no Azure e utiliza vários serviços do Azure e integrações de terceiros. Você precisa projetar e criar uma solução de monitoramento robusta que possa ser dimensionada com a expansão e fornecer insights sobre o desempenho da plataforma em diferentes regiões. O que você deve fazer?",
                        correctAnswer: "Implante várias instâncias do Application Insights para cada região e use o Azure Monitor para agregar os dados.",
                        explanation: "A opção A está correta porque a implantação de várias instâncias do Application Insights para cada região permite o monitoramento localizado, e o uso do Azure Monitor para agregar os dados fornece uma exibição centralizada do desempenho global. A opção B está incorreta, pois uma única instância pode não ser dimensionada de forma eficaz para monitoramento global. A opção D está incorreta porque a instrumentação manual e o armazenamento no Armazenamento de Blobs do Azure não fornecem recursos de monitoramento e análise em tempo real. A opção C está incorreta, os testes e alertas da Web são apenas parte de uma solução de monitoramento robusta.",
                        yourAnswer: "Implante várias instâncias do Application Insights para cada região e use o Azure Monitor para agregar os dados."
                    },
                    {
                        question: "Uma equipe de desenvolvimento está usando o Application Insights para monitorar seu aplicativo Web implantado no Azure. Eles notaram discrepâncias nas métricas relatadas devido ao alto volume de telemetria. Você precisa garantir que as métricas relatadas reflitam com precisão o desempenho do aplicativo sem serem afetadas pela amostragem de telemetria. O que você deve implementar para atingir esse objetivo?",
                        correctAnswer: "Configure o Application Insights para usar métricas padrão pré-agregadas para painéis e alertas em tempo real.",
                        explanation: "As métricas padrão pré-agregadas não são afetadas pela amostragem de telemetria e fornecem dados precisos em tempo real, o que as torna adequadas para painéis e alertas. Aumentar a taxa de amostragem ou desabilitar completamente a amostragem aumentaria os custos e ainda pode não fornecer métricas precisas devido ao volume de dados. A criação de uma consulta personalizada do Kusto exigiria esforço manual e não aborda o problema da amostragem que afeta as métricas.",
                        yourAnswer: "Configure o Application Insights para usar métricas padrão pré-agregadas para painéis e alertas em tempo real."
                    },
                    {
                        question: "Uma empresa usa o Gerenciamento de API do Azure para expor alguns de seus serviços. Cada desenvolvedor que consome APIs deve usar uma única chave para obter acesso a várias APIs sem a necessidade de aprovação do editor de API. Você precisa recomendar uma solução. Qual solução você deve recomendar?",
                        correctAnswer: "Defina uma assinatura com o escopo do produto.",
                        explanation: "Este item testa o conhecimento do candidato sobre assinaturas do Gerenciamento de API do Azure. Ao criar um produto, várias APIs podem ser adicionadas ao produto e uma assinatura pode ser associada a ele. O acesso não deve ser concedido a todas as APIs. O acesso do desenvolvedor deve ser concedido independentemente do IP do chamador. Um certificado de cliente exigiria uma política para validar o certificado e a lógica específica para mapear o cliente para APIs específicas.",
                        yourAnswer: "Defina uma assinatura com o escopo do produto."
                    },
                    {
                        question: "Você gerencia APIs em produção usando o Gerenciamento de API do Azure. Você precisa remover cabeçalhos X-Powered-By e X-AspNet-Version de uma resposta. Qual segmento de código você deve usar?",
                        correctAnswer: "<policies><inbound><base /></inbound><backend><base /></backend><outbound><set-header name=\"X-Powered-By\" exists-action=\"delete\" /><set-header name=\"X-AspNet-Version\" exists-action=\"delete\" /><base /></outbound><on-error><base /></on-error></policies>",
                        explanation: "Este item testa o conhecimento do candidato de definir políticas para APIs usando o Gerenciamento de API do Azure. O segmento de código que inclui o set-header policy elemento na seção de saída e exists-action=\"delete\" removerá um cabeçalho da resposta HTTP. O segmento de código que inclui o exists-action com valor de anexação não remove os cabeçalhos especificados. Os segmentos de código que não incluem o set-header policy elemento na seção de saída não removerão um cabeçalho da resposta HTTP.",
                        yourAnswer: "<policies><inbound><base /></inbound><backend><base /></backend><outbound><set-header name=\"X-Powered-By\" exists-action=\"delete\" /><set-header name=\"X-AspNet-Version\" exists-action=\"delete\" /><base /></outbound><on-error><base /></on-error></policies>"
                    },
                    {
                        question: "Uma empresa está usando o Gerenciamento de API do Azure para expor suas APIs a parceiros externos. A empresa deseja garantir que as APIs sejam acessíveis somente aos usuários autenticados com o OAuth 2.0 e que as cotas de uso sejam impostas para evitar abusos. Você precisa configurar a instância de Gerenciamento de API para atender aos requisitos de segurança e uso. Quais são as duas ações que você deve executar?",
                        correctAnswer: "Configure uma política validate-jwt para autenticar solicitações de entrada. e Configure um limite de taxa por política de chave para impor cotas de chamadas.",
                        explanation: "A configuração de uma política validate-jwt é necessária para autenticar usuários com o OAuth 2.0. Configurar um limite de taxa por política de chave ajuda a impor cotas de uso. A filtragem de IP não atende aos requisitos de autenticação e cota. A implantação de um Gateway de Aplicativo do Azure não é necessária para essas necessidades específicas.",
                        yourAnswer: "Configure uma política validate-jwt para autenticar solicitações de entrada. e Configure um limite de taxa por política de chave para impor cotas de chamadas."
                    },
                    {
                        question: "Você é um arquiteto de soluções de nuvem que trabalha em uma empresa que recentemente adotou os serviços de Gerenciamento de API do Microsoft Azure para centralizar o gerenciamento de suas APIs. A faculdade tem vários serviços de back-end que fornecem informações sobre cursos, docentes e serviços estudantis. Esses serviços são consumidos por vários aplicativos de front-end, incluindo o site público da faculdade, o portal do aluno e aplicativos móveis. Você precisa garantir que a instância de Gerenciamento de API esteja configurada para expor apenas as operações necessárias, manter a segurança e fornecer a capacidade de simular respostas para fins de teste sem invocar os serviços de back-end. O que você deve fazer?",
                        correctAnswer: "Crie uma API em branco e defina manualmente as operações necessárias e implemente políticas para validar tokens JWT e limitar as taxas de chamada.",
                        explanation: "A opção C está correta porque a criação de uma API em branco e a definição das operações necessárias manualmente permitem um controle preciso sobre o que é exposto, e a implementação de políticas para validação JWT e limitação de taxa aprimora a segurança. A opção D está incorreta porque a importação de todos os serviços de back-end sem filtragem expõe operações desnecessárias. A opção A está incorreta porque expor automaticamente todas as operações pode levar a riscos de segurança e pode não atender ao requisito de respostas simuladas. A opção B está incorreta, pois usar uma operação curinga pode tornar a API vulnerável a ameaças de segurança e não fornece a capacidade de simular respostas.",
                        yourAnswer: "Crie uma API em branco e defina manualmente as operações necessárias e implemente políticas para validar tokens JWT e limitar as taxas de chamada."
                    },
                    {
                        question: "Você é um arquiteto de soluções de nuvem que trabalha para uma empresa que planeja expor o serviço de processamento de dados interno deles, que atualmente está hospedado no Azure, aos parceiros deles por meio de APIs. O serviço processa grandes conjuntos de dados e fornece recursos de análise e relatório. A empresa deseja garantir que a API esteja bem documentada, que o acesso seja controlado com segurança e que as políticas de uso sejam impostas. Você precisa criar uma instância de Gerenciamento de API do Azure que permita acesso seguro e controlado às APIs com a capacidade de impor políticas de uso e documentar as APIs para seus parceiros. Quais são as três etapas que você deve executar?",
                        correctAnswer: "Configure o acesso às APIs configurando a autorização de usuário do OAuth 2.0 na instância de Gerenciamento de API do Azure. Crie uma instância de Gerenciamento de API do Azure e importe a API existente usando a funcionalidade de importação de API do portal do Azure. Implemente políticas para as APIs na instância de Gerenciamento de API do Azure para impor limites de taxa e cotas.",
                        explanation: "A opção B está correta porque criar uma instância do Gerenciamento de API do Azure e importar a API existente é uma maneira direta de expor o serviço interno aos parceiros. A opção C está incorreta, pois configurar uma API simulada não atende à necessidade imediata de expor o serviço real. A opção E está correta porque a implementação de políticas é essencial para controlar o uso das APIs. A opção D está incorreta porque a documentação deve ser gerenciada na instância de Gerenciamento de API do Azure, não no código de serviço. A opção A está correta, pois configurar o OAuth 2.0 na instância de Gerenciamento de API do Azure fornecerá controle de acesso seguro para as APIs.",
                        yourAnswer: "Configure o acesso às APIs configurando a autorização de usuário do OAuth 2.0 na instância de Gerenciamento de API do Azure. Crie uma instância de Gerenciamento de API do Azure e importe a API existente usando a funcionalidade de importação de API do portal do Azure. Implemente políticas para as APIs na instância de Gerenciamento de API do Azure para impor limites de taxa e cotas."
                    },
                    {
                        question: "Você gerencia um hub de eventos do Azure. Você precisa garantir que várias instâncias com balanceamento de carga de um aplicativo .NET (versão 5.0) possam ser usadas para dimensionar o processamento de eventos. Qual cliente do processador de eventos você deve usar?",
                        correctAnswer: "EventProcessorClient",
                        explanation: "Este item testa o conhecimento do candidato sobre a colocação em escala de aplicativos de processamento de eventos, que faz parte do desenvolvimento de soluções baseadas em eventos. EventProcessorClient equilibra a carga entre várias instâncias de um programa em versões mais recentes do .NET (versão 5.0). EventHubConsumerClient equilibra a carga entre várias instâncias de um programa em Python e JavaScript. EventProcessorHost equilibra a carga entre várias instâncias de um programa em versões anteriores do .NET. A classe EventHubProducerClient é usada para enviar eventos para um hub de eventos.",
                        yourAnswer: "EventProcessorClient"
                    },
                    {
                        question: "Você desenvolve o código a seguir para ler todos os eventos publicados para a primeira partição nos Hubs de Eventos do Azure. Você precisa concluir o código. Quais são as duas ações que você deve executar? Cada resposta correta apresenta uma parte da solução.",
                        correctAnswer: "Insira o seguinte segmento de código na linha 6: EventPosition startingPosition = EventPosition.Earliest; e Insira o seguinte segmento de código na linha 7: string partitionId = (await consumer.GetPartitionIdsAsync()).First();",
                        explanation: "Este item testa o conhecimento do candidato sobre a leitura de eventos dos Hubs de Eventos do Azure. Inserir o segmento de código que inclui startingPosition = EventPosition.Earliest na linha 6 usa a posição inicial mais antiga, que é necessária para ler todos os eventos publicados. Inserir o segmento de código que inclui string partitionId = (await consumer.GetPartitionIdsAsync()).First(); na linha 7 é necessário. O método GetPartitionIdsAsync() retorna uma cadeia de caracteres[]. O método First() retornará, portanto, uma cadeia de caracteres. O segmento de código na linha 6 que usa startingPosition = EventPosition.Latest não usa a posição inicial mais antiga. O segmento de código na linha 7 que inclui int partitionId está incorreto porque o método GetPartitionIdsAsync() retorna uma cadeia de caracteres[]. O método First() retornará, portanto, uma cadeia de caracteres e não um int, como a variável de retorno espera.",
                        yourAnswer: "Insira o seguinte segmento de código na linha 6: EventPosition startingPosition = EventPosition.Earliest; e Insira o seguinte segmento de código na linha 7: string partitionId = (await consumer.GetPartitionIdsAsync()).First();"
                    },
                    {
                        question: "Você precisa capturar eventos de streaming dos Hubs de Eventos do Azure. Para quais três locais você pode capturar dados? Cada resposta correta apresenta uma solução completa.",
                        correctAnswer: "Armazenamento de Blobs do Azure, Azure Data Lake Storage Gen1 e Azure Data Lake Storage Gen2",
                        explanation: "Este item testa o conhecimento do candidato sobre a implementação de soluções que usam os Hubs de Eventos do Azure. A Captura de Hubs de Eventos do Azure pode fornecer automaticamente os dados de streaming nos Hubs de Eventos para o Armazenamento de Blobs do Azure. A Captura de Hubs de Eventos do Azure pode fornecer automaticamente os dados de streaming nos Hubs de Eventos para o Azure Data Lake Storage Gen1. A Captura de Hubs de Eventos do Azure pode fornecer automaticamente os dados de streaming nos Hubs de Eventos para o Azure Data Lake Storage Gen2. O Azure Functions e o Azure Stream Analytics não podem ser usados para capturar eventos dos Hubs de Eventos do Azure.",
                        yourAnswer: "Armazenamento de Blobs do Azure, Azure Data Lake Storage Gen1 e Azure Data Lake Storage Gen2"
                    },
                    {
                        question: "Uma empresa está usando a Grade de Eventos do Azure para processar eventos de pedidos de comércio eletrônico. O sistema inclui várias fontes de eventos, como o Armazenamento de Blobs do Azure, o Azure Functions e serviços de terceiros. A empresa deseja garantir que o mecanismo de entrega de eventos seja robusto e possa lidar com diferentes cenários de falha, com perda mínima. Você precisa criar uma estratégia de entrega de eventos que garanta alta confiabilidade, mesmo quando os eventos resultam de códigos de resposta 400 ou 413. O que você deve fazer?",
                        correctAnswer: "Habilite a colocação em fila de mensagens mortas para capturar eventos que não são entregues dentro do agendamento de repetição especificado.",
                        explanation: "Habilitar mensagens mortas ajuda a capturar eventos que não podem ser entregues dentro do agendamento de repetição especificado, garantindo que nenhum dado seja perdido durante interrupções temporárias. Aumentar o número máximo de tentativas de entrega não garante a entrega se o sistema está inativo e pode levar a atrasos desnecessários. A validação síncrona do handshake está relacionada à validação da assinatura, não à confiabilidade da entrega de eventos. A diminuição do TTL do evento poderá resultar em eventos válidos sendo descartados se o sistema estiver temporariamente indisponível.",
                        yourAnswer: "Habilite a colocação em fila de mensagens mortas para capturar eventos que não são entregues dentro do agendamento de repetição especificado."
                    },
                    {
                        question: "Uma empresa está desenvolvendo um aplicativo multilocatário que lidará com grandes volumes de eventos de várias fontes. O aplicativo precisa ser capaz de processar e analisar esses eventos em tempo real. Você precisa criar um serviço de ingestão de eventos que forneça isolamento de dados e isolamento de desempenho para evitar problemas barulhentos de vizinhos, considerando também a complexidade operacional e o custo. Qual modelo de isolamento dos Hubs de Eventos você deve implementar?",
                        correctAnswer: "Namespace dedicado para cada locatário",
                        explanation: "A resposta correta é \"Namespace dedicado para cada locatário\" porque fornece o nível mais alto de isolamento de dados e desempenho, o que é essencial para evitar problemas de vizinhos barulhentos em um aplicativo multilocatário. \"Namespace compartilhado com hubs de eventos dedicados para cada locatário\" oferece isolamento médio e ainda pode levar a problemas de vizinhos barulhentos. \"Namespace compartilhado e hubs de eventos para todos os locatários\" fornece o nível mais baixo de isolamento e não é adequado para os requisitos fornecidos. \"Multilocação confiável com assinaturas de acesso compartilhado\" não é um modelo de isolamento, mas uma maneira de gerenciar o acesso em um ambiente compartilhado.",
                        yourAnswer: "Namespace dedicado para cada locatário"
                    },
                    {
                        question: "Você cria um tópico do Barramento de Serviço do Azure com um tempo de vida útil padrão de 10 minutos. Você precisa enviar mensagens para este tópico com um tempo de vida útil de 15 minutos. A solução não deve afetar outros aplicativos que estão usando o tópico. O que você deve recomendar?",
                        correctAnswer: "Crie um novo tópico com uma vida útil padrão de 15 minutos. Envie as mensagens para este tópico.",
                        explanation: "Essa pergunta testa o conhecimento do candidato sobre a expiração da mensagem do Barramento de Serviço do Azure. Para evitar afetar aplicativos existentes, o tempo de vida do tópico existente não deve ser alterado. Um novo tópico precisa ser criado. Alterar o tempo de vida padrão do tópico afetará outros aplicativos. Um tempo de vida em nível de mensagem não pode ser maior do que o tempo de vida do tópico. Para evitar afetar aplicativos existentes, o tempo de vida do tópico ou da fila existente não deve ser alterado.",
                        yourAnswer: "Crie um novo tópico com uma vida útil padrão de 15 minutos. Envie as mensagens para este tópico."
                    },
                    {
                        question: "Você tem uma fila do Barramento de Serviço do Azure. Você precisa garantir que um editor possa enviar mensagens para um tópico e que vários assinantes possam se tornar elegíveis para consumir as mensagens. Qual padrão de roteamento de mensagens você deve usar?",
                        correctAnswer: "solicitação/resposta multicast",
                        explanation: "Este item testa o conhecimento do candidato sobre o roteamento de mensagens no Barramento de Serviço do Azure, que faz parte do desenvolvimento de soluções baseadas em mensagens. Um editor pode enviar uma mensagem para um tópico e vários assinantes podem se tornar elegíveis para consumir a mensagem. Um editor pode enviar uma mensagem para uma fila e esperar uma resposta do consumidor da mensagem, mas vários assinantes não podem consumir a mensagem. Esse recurso de sessão permite a multiplexação de fluxos de mensagens relacionadas por meio de uma única fila, mas não pode ser consumido por vários assinantes. Esse recurso de sessão permite a multiplexação de respostas, permitindo que vários editores compartilhem uma fila de resposta, mas uma mensagem não pode ser consumida por vários assinantes.",
                        yourAnswer: "solicitação/resposta multicast"
                    },
                    {
                        question: "Uma empresa de serviços financeiros está implementando um sistema para processar transações recebidas como mensagens. O sistema precisa garantir que as transações sejam processadas apenas uma vez e, na ordem exata, sejam recebidas para manter a integridade dos dados. Você precisa criar uma solução de mensagens que garanta a entrega e o processamento de mensagens PEPS (primeiro a entrar, primeiro a sair). Quais dois serviços você deve usar?",
                        correctAnswer: "Barramento de Serviço do Azure com detecção duplicada e Fila do Barramento de Serviço com a opção Sessões habilitada",
                        explanation: "O Barramento de Serviço do Azure com sessões habilitadas permite o processamento PEPS usando sessões para garantir que as mensagens relacionadas sejam tratadas na ordem em que são recebidas. A detecção duplicada ajuda a garantir que o sistema não processe a mesma transação mais de uma vez. O Armazenamento de Filas do Azure não garante o processamento PEPS, pois ele não dá suporte a sessões e o tempo limite de visibilidade apenas oculta a mensagem temporariamente de outros consumidores. A Grade de Eventos do Azure é um serviço de roteamento de eventos e não fornece garantias de PEPS ou sessões de mensagem.",
                        yourAnswer: "Barramento de Serviço do Azure com detecção duplicada e Fila do Barramento de Serviço com a opção Sessões habilitada"
                    }
                ];
            };

            const setActiveView = (viewId) => {
                activeView = viewId;

                Object.values(views).forEach(view => view.classList.add('hidden-view'));
                views[viewId].classList.remove('hidden-view');

                Object.values(navButtons).forEach(button => button.classList.remove('active'));
                if (navButtons[viewId]) {
                    navButtons[viewId].classList.add('active');
                }
                mobileNavSelect.value = viewId;

                if (viewId === 'dashboard') {
                    renderExamWeightsChart();
                    renderServicesGrid();
                } else if (viewId === 'compare') {
                    renderComparisonSelects();
                    updateComparison();
                } else if (viewId === 'cli') {
                    renderCliSdkContent();
                } else if (viewId === 'quiz') {
                    renderQuizQuestions();
                }
            };

            const renderExamWeightsChart = () => {
                const ctx = document.getElementById('examWeightsChart');
                if (!ctx) {
                    console.error('Canvas element for examWeightsChart not found.');
                    return;
                }
                if (charts.examWeights) charts.examWeights.destroy();

                const labels = Object.values(domains).map(d => d.name);
                const data = Object.values(domains).map(d => d.weight);
                const colors = Object.values(domains).map(d => d.color);

                charts.examWeights = new Chart(ctx.getContext('2d'), {
                    type: 'doughnut',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Peso no Exame (%)',
                            data: data,
                            backgroundColor: colors,
                            borderColor: '#F8F7F4',
                            borderWidth: 4,
                            hoverOffset: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '60%',
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    padding: 15,
                                    boxWidth: 12,
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed !== null) {
                                            label += context.parsed + '%';
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const chartElement = elements[0];
                                const domainKey = Object.keys(domains)[chartElement.index];
                                setFilter(domainKey);
                            }
                        }
                    }
                });
            };

            const renderDomainFilterButtons = () => {
                domainFilterButtonsContainer.innerHTML = '';
                const allButton = document.createElement('button');
                allButton.dataset.filter = 'all';
                allButton.classList.add('filter-button', 'p-3', 'rounded-lg', 'text-sm', 'font-semibold', 'transition-colors', 'duration-200');
                allButton.textContent = 'Todos';
                domainFilterButtonsContainer.appendChild(allButton);

                Object.keys(domains).forEach(domainKey => {
                    const button = document.createElement('button');
                    button.dataset.filter = domainKey;
                    button.classList.add('filter-button', 'p-3', 'rounded-lg', 'text-sm', 'font-semibold', 'transition-colors', 'duration-200');
                    button.textContent = domains[domainKey].name;
                    domainFilterButtonsContainer.appendChild(button);
                });

                domainFilterButtonsContainer.addEventListener('click', (event) => {
                    if (event.target.classList.contains('filter-button')) {
                        setFilter(event.target.dataset.filter);
                    }
                });
                updateFilterButtonStyles();
            };

            const updateFilterButtonStyles = () => {
                document.querySelectorAll('.filter-button').forEach(button => {
                    if (button.dataset.filter === activeFilter) {
                        button.classList.add('bg-[#81B29A]', 'text-white');
                        button.classList.remove('bg-gray-100', 'hover:bg-gray-200');
                    } else {
                        button.classList.remove('bg-[#81B29A]', 'text-white');
                        button.classList.add('bg-gray-100', 'hover:bg-gray-200');
                    }
                });
            };

            const setFilter = (domain) => {
                activeFilter = domain;
                updateFilterButtonStyles();
                renderServicesGrid();
                document.getElementById('services').scrollIntoView({ behavior: 'smooth' });
            };

            const renderServicesGrid = () => {
                servicesGrid.innerHTML = '';
                const filtered = activeFilter === 'all' ? servicesData : servicesData.filter(service => service.domain === activeFilter);

                if (filtered.length === 0) {
                    noServicesMessage.classList.remove('hidden');
                } else {
                    noServicesMessage.classList.add('hidden');
                    filtered.forEach(service => {
                        const serviceCard = document.createElement('div');
                        serviceCard.classList.add('service-card', 'bg-white', 'p-6', 'rounded-2xl', 'shadow-md', 'cursor-pointer', 'flex', 'flex-col', 'items-center', 'text-center');
                        serviceCard.innerHTML = `
                            <div class="w-16 h-16 rounded-full flex items-center justify-center mb-4" style="background-color: ${domains[service.domain].color}">
                                <span class="text-3xl text-white">${service.icon}</span>
                            </div>
                            <h3 class="font-bold text-lg">${service.name}</h3>
                            <p class="text-sm text-gray-500 mt-2">${service.tagline}</p>
                        `;
                        serviceCard.addEventListener('click', () => openModal(service));
                        servicesGrid.appendChild(serviceCard);
                    });
                }
            };

            const openModal = (service) => {
                selectedService = service;
                modalIconContainer.style.backgroundColor = domains[selectedService.domain].color;
                modalIcon.innerHTML = selectedService.icon;
                modalName.textContent = selectedService.name;
                modalTagline.textContent = selectedService.tagline;
                renderModalBody();
                serviceModal.style.display = 'flex';
                isModalOpen = true;
            };

            const closeModal = () => {
                serviceModal.style.display = 'none';
                isModalOpen = false;
                selectedService = null;
            };

            const renderModalBody = () => {
                modalBodyContent.innerHTML = `
                    <div class="space-y-8">
                        <div class="modal-section">
                            <h3 class="text-xl font-bold cursor-pointer flex justify-between items-center">
                                Visão Geral e Características
                                <span class="toggle-icon text-2xl">−</span>
                            </h3>
                            <div class="mt-4 prose max-w-none text-gray-700">${selectedService.details.overview}</div>
                        </div>
                        <div class="modal-section">
                            <h3 class="text-xl font-bold cursor-pointer flex justify-between items-center">
                                Aplicações e Casos de Uso
                                <span class="toggle-icon text-2xl">+</span>
                            </h3>
                            <div class="mt-4 prose max-w-none text-gray-700 hidden">${selectedService.details.useCases}</div>
                        </div>
                        <div class="modal-section">
                            <h3 class="text-xl font-bold cursor-pointer flex justify-between items-center">
                                Limitações e Considerações
                                <span class="toggle-icon text-2xl">+</span>
                            </h3>
                            <div class="mt-4 prose max-w-none text-gray-700 hidden">${selectedService.details.limitations}</div>
                        </div>
                        ${(selectedService.cli || selectedService.sdk) ? `
                        <div class="modal-section">
                            <h3 class="text-xl font-bold cursor-pointer flex justify-between items-center">
                                Implementação Prática (CLI & SDK)
                                <span class="toggle-icon text-2xl">+</span>
                            </h3>
                            <div class="mt-4 space-y-6 hidden">
                                ${selectedService.cli ? `
                                    <div>
                                        <h4 class="text-lg font-semibold mb-2">Azure CLI</h4>
                                        ${selectedService.cli.map(cmd => `
                                            <div class="mb-4">
                                                <div class="code-block bg-gray-800 text-white p-4 rounded-lg font-mono text-sm overflow-x-auto">
                                                    <button class="copy-button" data-clipboard-text="${cmd.command.replace(/"/g, '&quot;')}">Copiar</button>
                                                    <p class="text-gray-400"># ${cmd.description}</p>
                                                    <p>${cmd.command}</p>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                                ${selectedService.sdk ? `
                                    <div>
                                        <h4 class="text-lg font-semibold mb-2">SDK (.NET/C#)</h4>
                                        ${selectedService.sdk.map(code => `
                                            <div class="mb-4">
                                                <p class="text-md font-medium mb-1">${code.description}</p>
                                                <div class="code-block bg-gray-800 text-white p-4 rounded-lg font-mono text-sm overflow-x-auto">
                                                    <button class="copy-button" data-clipboard-text="${code.snippet.replace(/"/g, '&quot;')}">Copiar</button>
                                                    <pre><code>${code.snippet}</code></pre>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                `;
                addModalToggleListeners();
                addCopyButtonListeners();
            };

            const addModalToggleListeners = () => {
                document.querySelectorAll('.modal-section h3').forEach(header => {
                    header.addEventListener('click', (event) => {
                        const sectionContent = header.nextElementSibling;
                        const toggleIcon = header.querySelector('.toggle-icon');
                        if (sectionContent.classList.contains('hidden')) {
                            sectionContent.classList.remove('hidden');
                            if (toggleIcon) toggleIcon.textContent = '−';
                        } else {
                            sectionContent.classList.add('hidden');
                            if (toggleIcon) toggleIcon.textContent = '+';
                        }
                    });
                });
            };

            const addCopyButtonListeners = () => {
                document.querySelectorAll('.copy-button').forEach(button => {
                    button.addEventListener('click', () => {
                        const textToCopy = button.dataset.clipboardText;
                        copyToClipboard(textToCopy);
                    });
                });
            };

            const copyToClipboard = (text) => {
                const el = document.createElement('textarea');
                el.value = text;
                document.body.appendChild(el);
                el.select();
                document.execCommand('copy');
                document.body.removeChild(el);
                alert('Copiado para a área de transferência!');
            };

            const renderComparisonSelects = () => {
                const optionsHtml = servicesData.map(service => `<option value="${service.id}">${service.name}</option>`).join('');
                compareSelect1.innerHTML = '<option value="">Selecione...</option>' + optionsHtml;
                compareSelect2.innerHTML = '<option value="">Selecione...</option>' + optionsHtml;

                if (comparison.service1) compareSelect1.value = comparison.service1;
                if (comparison.service2) compareSelect2.value = comparison.service2;
            };

            const updateComparison = () => {
                comparison.service1 = compareSelect1.value;
                comparison.service2 = compareSelect2.value;

                comparison.data1 = servicesData.find(s => s.id === comparison.service1);
                comparison.data2 = servicesData.find(s => s.id === comparison.service2);

                if (comparison.data1 && comparison.data2) {
                    noComparisonSelectedDiv.style.display = 'none';
                    comparisonResultsDiv.style.display = 'block';
                    renderComparisonColumns();
                    renderComparisonChart();
                } else {
                    noComparisonSelectedDiv.style.display = 'block';
                    comparisonResultsDiv.style.display = 'none';
                    if (charts.comparison) charts.comparison.destroy();
                }
            };

            const renderComparisonColumns = () => {
                comparisonColumnsDiv.innerHTML = '';
                if (comparison.data1) {
                    comparisonColumnsDiv.innerHTML += renderComparisonColumnHtml(comparison.data1);
                }
                if (comparison.data2) {
                    comparisonColumnsDiv.innerHTML += renderComparisonColumnHtml(comparison.data2);
                }
            };

            const renderComparisonColumnHtml = (data) => {
                if (!data) return '';
                return `
                    <div class="bg-gray-50 p-6 rounded-2xl h-full">
                        <div class="flex items-center space-x-3 mb-4">
                            <div class="w-10 h-10 rounded-full flex-shrink-0 flex items-center justify-center" style="background-color: ${domains[data.domain].color}">
                                <span class="text-2xl text-white">${data.icon}</span>
                            </div>
                            <h3 class="text-2xl font-bold">${data.name}</h3>
                        </div>
                        <div class="space-y-4">
                            <div><h4 class="font-semibold">Visão Geral</h4><div class="prose prose-sm max-w-none text-gray-600">${data.details.overview}</div></div>
                            <div><h4 class="font-semibold">Casos de Uso</h4><div class="prose prose-sm max-w-none text-gray-600">${data.details.useCases}</div></div>
                            <div><h4 class="font-semibold">Limitações</h4><div class="prose prose-sm max-w-none text-gray-600">${data.details.limitations}</div></div>
                        </div>
                    </div>
                `;
            };

            const renderComparisonChart = () => {
                const ctx = document.getElementById('comparisonChart');
                if (!ctx) {
                    console.error('Canvas element for comparisonChart not found.');
                    return;
                }
                if (charts.comparison) charts.comparison.destroy();
                if (!comparison.data1 || !comparison.data2) return;
                
                const labels = Object.keys(comparison.data1.comparison_metrics);
                const data1 = Object.values(comparison.data1.comparison_metrics);
                const data2 = Object.values(comparison.data2.comparison_metrics);
                
                charts.comparison = new Chart(ctx.getContext('2d'), {
                    type: 'radar',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: comparison.data1.name,
                                data: data1,
                                backgroundColor: 'rgba(129, 178, 154, 0.2)',
                                borderColor: 'rgba(129, 178, 154, 1)',
                                borderWidth: 2,
                                pointBackgroundColor: 'rgba(129, 178, 154, 1)',
                            },
                            {
                                label: comparison.data2.name,
                                data: data2,
                                backgroundColor: 'rgba(224, 122, 95, 0.2)',
                                borderColor: 'rgba(224, 122, 95, 1)',
                                borderWidth: 2,
                                pointBackgroundColor: 'rgba(224, 122, 95, 1)',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            r: {
                                angleLines: { color: '#ddd' },
                                grid: { color: '#eee' },
                                pointLabels: { font: { size: 12 } },
                                ticks: {
                                    beginAtZero: true,
                                    min: 0,
                                    max: 5,
                                    stepSize: 1,
                                    backdropColor: 'rgba(255, 255, 255, 0.75)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        }
                    }
                });
            };

            const renderCliSdkContent = () => {
                cliSdkContentDiv.innerHTML = '';
                servicesData.filter(s => s.cli || s.sdk).forEach(service => {
                    let serviceHtml = `
                        <div class="bg-white p-6 rounded-2xl shadow-lg">
                            <h3 class="text-2xl font-bold mb-4">${service.name}</h3>
                            <div class="space-y-6">
                    `;
                    if (service.cli) {
                        serviceHtml += `
                                <div>
                                    <h4 class="text-lg font-semibold mb-2">Azure CLI</h4>
                                    ${service.cli.map(cmd => `
                                        <div class="mb-4">
                                            <div class="code-block bg-gray-800 text-white p-4 rounded-lg font-mono text-sm overflow-x-auto">
                                                <button class="copy-button" data-clipboard-text="${cmd.command.replace(/"/g, '&quot;')}">Copiar</button>
                                                <p class="text-gray-400"># ${cmd.description}</p>
                                                <p>${cmd.command}</p>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                        `;
                    }
                    if (service.sdk) {
                        serviceHtml += `
                                <div>
                                    <h4 class="text-lg font-semibold mb-2">SDK (.NET/C#)</h4>
                                    ${service.sdk.map(code => `
                                        <div class="mb-4">
                                            <p class="text-md font-medium mb-1">${code.description}</p>
                                            <div class="code-block bg-gray-800 text-white p-4 rounded-lg font-mono text-sm overflow-x-auto">
                                                <button class="copy-button" data-clipboard-text="${code.snippet.replace(/"/g, '&quot;')}">Copiar</button>
                                                <pre><code>${code.snippet}</code></pre>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                        `;
                    }
                    serviceHtml += `
                            </div>
                        </div>
                    `;
                    cliSdkContentDiv.innerHTML += serviceHtml;
                });
                addCopyButtonListeners();
            };

            const renderQuizQuestions = () => {
                quizQuestionsContainer.innerHTML = '';
                quizQuestions.forEach((q, index) => {
                    const questionCard = document.createElement('div');
                    questionCard.classList.add('question-card');
                    questionCard.innerHTML = `
                        <p class="question-text"><strong>Pergunta ${index + 1}:</strong> ${q.question}</p>
                        <button class="show-answer-button" data-question-index="${index}">Mostrar Resposta</button>
                        <div class="answer-section hidden" id="answer-section-${index}">
                            <p class="answer-correct"><strong>Resposta Correta:</strong> ${q.correctAnswer}</p>
                            <p class="answer-explanation"><strong>Sua Resposta:</strong> ${q.yourAnswer}</p>
                            <p class="answer-explanation"><strong>Explicação:</strong> ${q.explanation}</p>
                        </div>
                    `;
                    quizQuestionsContainer.appendChild(questionCard);
                });

                document.querySelectorAll('.show-answer-button').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const index = event.target.dataset.questionIndex;
                        const answerSection = document.getElementById(`answer-section-${index}`);
                        answerSection.classList.toggle('hidden');
                        if (answerSection.classList.contains('hidden')) {
                            event.target.textContent = 'Mostrar Resposta';
                        } else {
                            event.target.textContent = 'Esconder Resposta';
                        }
                    });
                });
            };

            const init = () => {
                loadData();
                renderDomainFilterButtons();
                renderServicesGrid();
                setActiveView('dashboard');

                navButtons.dashboard.addEventListener('click', () => setActiveView('dashboard'));
                navButtons.compare.addEventListener('click', () => setActiveView('compare'));
                navButtons.cli.addEventListener('click', () => setActiveView('cli'));
                navButtons.quiz.addEventListener('click', () => setActiveView('quiz'));
                mobileNavSelect.addEventListener('change', (event) => setActiveView(event.target.value));

                compareSelect1.addEventListener('change', updateComparison);
                compareSelect2.addEventListener('change', updateComparison);

                modalCloseButton.addEventListener('click', closeModal);
                serviceModal.addEventListener('click', (event) => {
                    if (event.target === serviceModal) {
                        closeModal();
                    }
                });
            };

            return {
                init,
                setActiveView,
                setFilter,
                openModal,
                closeModal,
                copyToClipboard,
                domains,
                servicesData,
                comparison,
            };
        })();

        document.addEventListener('DOMContentLoaded', app.init);
    </script>
</body>
</html>
�